<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Philippe Marchand, Université du Québec en Abitibi-Témiscamingue" />


<title>Introduction au traitement des données géospatiales avec R</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<link href="libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Introduction au traitement des données géospatiales avec R</h1>
<h4 class="author">Philippe Marchand, Université du Québec en Abitibi-Témiscamingue</h4>
<h4 class="date">7 mai 2020</h4>

</div>


<hr />
<p>Cet atelier se veut un survol des outils disponibles en R pour l’analyse de données géoréférencées. Ce type de données apparaît de plus en plus fréquemment dans divers domaines (ex.: photos aériennes, images satellite, données du recensement, lieux rattachés aux messages sur les réseaux sociaux, etc.). Il existe deux grandes catégories de données géoréférencées:</p>
<ul>
<li>les données matricielles représentent des variables définies à chaque point d’une grille couvrant tout l’espace représenté (comme une image satellite);</li>
<li>les données vectorielles associent des variables à des objets géométriques placés à des endroits précis (comme la position des villes et des chemins sur une carte routière).</li>
</ul>
<p>Au départ, l’utilisation de commandes de programmation pour manipuler des données géographiques peut sembler moins intuitive que l’interface graphique de logiciels spécialisés (ex.: ArcGIS). Voici quelques avantages d’une analyse programmée:</p>
<ul>
<li>Il est facile de répéter l’analyse pour de nouvelles données en ré-exécutant le programme.</li>
<li>Il est facile pour d’autres chercheurs de reproduire la méthodologie s’ils ont accès au même langage de programmation.</li>
<li>Dans le cas spécifique de R, on peut extraire des variables spatiales et les combiner à d’autres analyses statistiques avec un seul programme.</li>
</ul>
<div id="objectifs" class="section level2">
<h2>Objectifs</h2>
<ul>
<li>Se familiariser avec des packages R permettant le traitement et la visualisation simple de données vectorielles (<strong><em>sf</em></strong>) et matricielles (<strong><em>stars</em></strong>).</li>
<li>Effectuer des transformations de données courantes à l’aide des fonctions de ces packages.</li>
<li>Connaître certains packages permettant des visualisations plus complexes: <strong><em>ggplot2</em></strong> pour des cartes statiques et <strong><em>mapview</em></strong> pour des cartes interactives.</li>
</ul>
<div id="note-sur-les-packages" class="section level3">
<h3>Note sur les packages</h3>
<ul>
<li><p>L’ensemble des packages disponibles pour l’analyse spatiale en R évolue rapidement. Il y a quelques années, les packages <strong><em>sp</em></strong> and <strong><em>raster</em></strong> étaient les principaux outils pour l’analyse des données vectorielles et matricielles, respectivement. <strong><em>sf</em></strong> et <strong><em>stars</em></strong> font partie d’une initiative récente pour faciliter le traitement des données spatiales dans R (<a href="https://www.r-spatial.org/">https://www.r-spatial.org/</a>).</p></li>
<li><p>Le package <strong><em>sf</em></strong> représente les tableaux de données spatiaux selon un format standard basé sur les bases de données géospatiales et s’intègre bien avec des packages populaires pour la manipulation et la visualisation des données (notamment <strong><em>dplyr</em></strong> et <strong><em>ggplot2</em></strong>).</p></li>
<li><p>Le package <strong><em>stars</em></strong> est aussi compatible avec <strong><em>ggplot2</em></strong> et représente bien les “cubes” de données avec des dimensions supplémentaires aux deux dimensions spatiales, comme le temps.</p></li>
<li><p>Le package <strong><em>raster</em></strong> et son successeur <strong><em>terra</em></strong> (lancé en 2020) contiennent certaines fonctionnalités supplémentaires relatives à <strong><em>stars</em></strong> et réalisent certaines opérations plus rapidement. Ainsi, il peut être utile d’apprendre à les utiliser si vous devez réaliser des opérations complexes sur des données matricielles massives; voir la documentation sur <a href="https://rspatial.org/">https://rspatial.org/</a> pour plus de détails.</p></li>
</ul>
</div>
</div>
<div id="table-des-matières" class="section level2">
<h2>Table des matières</h2>
<ul>
<li><a href="#vect">Explorer un jeu de données vectoriel</a></li>
<li><a href="#crs">Systèmes de coordonnées et transformations</a></li>
<li><a href="#geomsf">Cartes détaillées avec ggplot2</a></li>
<li><a href="#vectop">Opérations géométriques sur les données vectorielles</a></li>
<li><a href="#rast">Traitement des données matricielles</a></li>
<li><a href="#mapview">Cartes interactives avec <em>mapview</em></a></li>
<li><a href="#ref">Références supplémentaires</a></li>
<li><a href="#data">Sources des données</a></li>
<li><a href="#sol">Solutions des exercices</a></li>
</ul>
<hr />
</div>
<div id="vect" class="section level2">
<h2>Explorer un jeu de données vectoriel</h2>
<p>Tous les jeux de données de cet atelier se trouvent dans le répertoire <em>data</em>. Le jeu de données <em>mrc</em> contient les coordonnées des municipalités régionales de comté (MRC) du Québec en format <em>ESRI shapefile</em>. Notez que l’information pour chaque jeu de données est contenue dans plusieurs fichiers, qui portent le même nom mais diffèrent par leur extension (<em>mrc.dbf</em>, <em>mrc.prj</em>, <em>mrc.shp</em> and <em>mrc.shx</em>).</p>
<p>Pour charger ce jeu de données dans R, nous appelons la fonction <code>st_read</code> (toutes les fonctions du package <strong><em>sf</em></strong> ont le préfixe <code>st_</code>, pour spatiotemporel) en spécifiant le chemin vers le fichier <em>.shp</em>.</p>
<pre class="r"><code>library(sf)

mrc &lt;- st_read(&quot;data/mrc.shp&quot;)</code></pre>
<pre><code>## Reading layer `mrc&#39; from data source `Z:\cours\atelier_rgeo\data\mrc.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 104 features and 4 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -79.7625 ymin: 44.99136 xmax: -56.93495 ymax: 62.58217
## CRS:            4269</code></pre>
<p>Le texte de sortie indique certaines propriétés du jeu de données chargé, incluant le type de géométrie (MULTIPOLYGON), les limites spatiales du jeu de données (<em>bbox</em>) et le système de coordonnées (CRS) utilisé.</p>
<p>Les limites spatiales et une description détaillée du système de coordonnées peuvent être extraits séparément à l’aide des fonctions <code>st_bbox</code> et <code>st_crs</code>:</p>
<pre class="r"><code>st_bbox(mrc)</code></pre>
<pre><code>##      xmin      ymin      xmax      ymax 
## -79.76250  44.99136 -56.93495  62.58217</code></pre>
<pre class="r"><code>st_crs(mrc)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: 4269 
##   wkt:
## GEOGCS[&quot;GCS_North_American_1983&quot;,
##     DATUM[&quot;North_American_Datum_1983&quot;,
##         SPHEROID[&quot;GRS_1980&quot;,6378137,298.257222101]],
##     PRIMEM[&quot;Greenwich&quot;,0],
##     UNIT[&quot;Degree&quot;,0.017453292519943295],
##     AUTHORITY[&quot;EPSG&quot;,&quot;4269&quot;]]</code></pre>
<p>Nous discuterons des systèmes de coordonnées dans la prochaine section. Notons pour l’instant que “Degree” dans le bloc “UNIT” indique qu’il s’agit de coordonnées de longitude et latitude exprimées en degrés décimaux.</p>
<p>Regardons un aperçu du jeu de données:</p>
<pre class="r"><code>class(mrc)</code></pre>
<pre><code>## [1] &quot;sf&quot;         &quot;data.frame&quot;</code></pre>
<pre class="r"><code>head(mrc)</code></pre>
<pre><code>## Simple feature collection with 6 features and 4 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -79.51776 ymin: 45.44911 xmax: -63.31941 ymax: 62.58217
## CRS:            4269
##                           mrc_name reg_id              reg_name pop2016
## 1                          Abitibi     08 Abitibi-Temiscamingue   24707
## 2                    Abitibi-Ouest     08 Abitibi-Temiscamingue   20582
## 3                            Acton     16            Monteregie   15623
## 4 Administration regionale Kativik     10        Nord-du-Quebec   13343
## 5                  Antoine-Labelle     15           Laurentides   35410
## 6                       Argenteuil     15           Laurentides   32477
##                         geometry
## 1 MULTIPOLYGON (((-78.64359 4...
## 2 MULTIPOLYGON (((-79.51776 4...
## 3 MULTIPOLYGON (((-72.70415 4...
## 4 MULTIPOLYGON (((-77.82293 5...
## 5 MULTIPOLYGON (((-75.52133 4...
## 6 MULTIPOLYGON (((-74.71004 4...</code></pre>
<p>Un objet de classe <code>sf</code> est en fait un <code>data.frame</code> spécialisé, où chaque ligne contient des champs de données qui sont associés à un élément géométrique, décrit dans la colonne <code>geometry</code>. Les types géométriques les plus courants sont:</p>
<ul>
<li>POINT: Coordonnées (<em>x</em>, <em>y</em>) d’un point.</li>
<li>LINESTRING: Séquence de points reliés par des segments de droite.</li>
<li>POLYGON: Séquence de points formant un polygone simple fermé.</li>
<li>MULTIPOINT, MULTILINESTRING ou MULTIPOLYGON: Jeu de données où chaque élément peut être composé de plusieurs points ou lignes ou polygones.</li>
</ul>
<p>La fonction <code>plot</code> appliquée à un objet <code>sf</code> crée une carte de chaque attribut du jeu de données.</p>
<pre class="r"><code>plot(mrc)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_sf-1.png" width="672" /></p>
<p>Pour n’afficher qu’un attribut, il faut sélectionner la colonne correspondante. Pour n’afficher que la carte sans données, on peut choisir la colonne <code>geometry</code>. Le paramètre <code>axes = TRUE</code> indique au programme d’afficher les axes de coordonnées.</p>
<pre class="r"><code>plot(mrc[, &quot;geometry&quot;], axes = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_geom-1.png" width="672" /></p>
<p>Vous pouvez choisir une partie des rangées ou des colonnes d’un objet <code>sf</code> comme s’il s’agissait d’un <code>data.frame</code> régulier.</p>
<pre class="r"><code># Choisir la 5e rangée
mrc[5, ]</code></pre>
<pre><code>## Simple feature collection with 1 feature and 4 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -76.14932 ymin: 45.95376 xmax: -74.34359 ymax: 47.76333
## CRS:            4269
##          mrc_name reg_id    reg_name pop2016                       geometry
## 5 Antoine-Labelle     15 Laurentides   35410 MULTIPOLYGON (((-75.52133 4...</code></pre>
<pre class="r"><code># Choisir le nom et la population de la MRC pour les MRC avec une population de 200 000 et plus
mrc[mrc$pop2016 &gt; 200000, c(&quot;mrc_name&quot;, &quot;pop2016&quot;)] </code></pre>
<pre><code>## Simple feature collection with 5 features and 2 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -75.90834 ymin: 45.37075 xmax: -71.13162 ymax: 46.98186
## CRS:            4269
##     mrc_name pop2016                       geometry
## 23  Gatineau  278198 MULTIPOLYGON (((-75.89532 4...
## 47     Laval  425225 MULTIPOLYGON (((-73.74488 4...
## 69 Longueuil  417497 MULTIPOLYGON (((-73.44474 4...
## 82  Montreal 1959836 MULTIPOLYGON (((-73.49801 4...
## 89    Quebec  572755 MULTIPOLYGON (((-71.55293 4...</code></pre>
<p>Notez que la colonne contenant l’information spatiale (<em>geometry</em>) demeure toujours dans le tableau, même si elle n’est pas choisie. Pour éliminer cette colonne et convertir l’objet <code>sf</code> en tableau de données régulier, vous pouvez utiliser la fonction <code>st_drop_geometry</code>.</p>
<div id="retour1" class="section level3">
<h3>Exercice 1</h3>
<p>Choisissez les MRC de la région du Bas-St-Laurent (<em>reg_id</em>: 01) et de la Gaspésie (<em>reg_id</em>: 11), puis affichez leur population de 2016 sur une carte. <em>Indice</em>: L’opérateur <code>%in%</code> permet de vérifier si une variable prend une valeur parmi une liste. Par exemple, <code>x %in% c(1, 3)</code> est égal à TRUE si <em>x = 1</em> ou <em>x = 3</em>.</p>
<p><a href="#sol1">Solution</a></p>
</div>
<div id="intégration-avec-le-package-dplyr" class="section level3">
<h3>Intégration avec le package dplyr</h3>
<p>Les fonctions de manipulation de données du package <strong><em>dplyr</em></strong> fonctionnent aussi sur des objets <code>sf</code>. Par exemple, nous pouvons réécrire l’exemple ci-dessus (choisir le nom et la population des MRC avec une population de plus de 200 000) avec <code>filter</code> et <code>select</code>.</p>
<pre class="r"><code>library(dplyr)

filter(mrc, pop2016 &gt; 200000) %&gt;%
    select(mrc_name, pop2016)</code></pre>
<pre><code>## Simple feature collection with 5 features and 2 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -75.90834 ymin: 45.37075 xmax: -71.13162 ymax: 46.98186
## CRS:            4269
##    mrc_name pop2016                       geometry
## 1  Gatineau  278198 MULTIPOLYGON (((-75.89532 4...
## 2     Laval  425225 MULTIPOLYGON (((-73.74488 4...
## 3 Longueuil  417497 MULTIPOLYGON (((-73.44474 4...
## 4  Montreal 1959836 MULTIPOLYGON (((-73.49801 4...
## 5    Quebec  572755 MULTIPOLYGON (((-71.55293 4...</code></pre>
<p>Lorsque nous calculons une statistique sommaire par groupe, les éléments géométriques sont aussi soudés pour chaque groupe. Pour illustrer ce point, regroupons les MRC et leur population par région.</p>
<pre class="r"><code>regions &lt;- group_by(mrc, reg_name) %&gt;%
    summarize(pop2016 = sum(pop2016))
head(regions)</code></pre>
<pre><code>## Simple feature collection with 6 features and 2 fields
## geometry type:  GEOMETRY
## dimension:      XY
## bbox:           xmin: -79.57933 ymin: 45.58943 xmax: -56.93495 ymax: 55.00006
## CRS:            4269
## # A tibble: 6 x 3
##   reg_name         pop2016                                              geometry
##   &lt;chr&gt;              &lt;dbl&gt;                                        &lt;GEOMETRY [°]&gt;
## 1 Abitibi-Temisca~  147282 POLYGON ((-77.93147 47.27012, -77.93155 47.26624, -7~
## 2 Bas-Saint-Laure~  197806 POLYGON ((-68.38319 47.88014, -68.38314 47.83307, -6~
## 3 Capitale-Nation~  733898 POLYGON ((-70.69151 47.03311, -70.69453 47.02324, -7~
## 4 Centre-du-Quebec  243354 POLYGON ((-72.09283 45.79699, -72.11938 45.77338, -7~
## 5 Chaudiere-Appal~  421993 POLYGON ((-70.2784 46.05675, -70.2784 46.05608, -70.~
## 6 Cote-Nord          92712 MULTIPOLYGON (((-66.25978 55.00001, -66.25001 55, -6~</code></pre>
<pre class="r"><code>plot(regions[&quot;pop2016&quot;])</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sf_groupby-1.png" width="672" /></p>
</div>
<div id="créer-un-objet-spatial-à-partir-dun-data-frame" class="section level3">
<h3>Créer un objet spatial à partir d’un <em>data frame</em></h3>
<p>Le fichier <code>plots.csv</code> contient des données sur les placettes d’inventaire du Ministère des Forêts, de la Faune et des Parcs du Québec (MFFP), incluant le numéro d’identification, la latitude et la longitude, la date d’inventaire, le type de couvert (feuillu, mixte ou confière) ainsi que la classe de hauteur.</p>
<pre class="r"><code>plots &lt;- read.csv(&quot;data/plots.csv&quot;)
head(plots)</code></pre>
<pre><code>##    plot_id      lat      long  surv_date cover_type height_cls
## 1 99100101 45.35944 -72.89580 2012-11-12  Deciduous    17-22 m
## 2 99100102 45.36267 -72.89244 2012-09-08  Deciduous      &gt;22 m
## 3 99100201 45.49196 -71.16727 2008-09-11  Deciduous    17-22 m
## 4 99100202 45.49068 -71.16180 2008-09-11  Deciduous    17-22 m
## 5 99100301 45.47711 -72.58792 2012-08-30  Deciduous      &gt;22 m
## 6 99100302 45.47969 -72.58448 2012-08-30  Deciduous      &gt;22 m</code></pre>
<p>Nous pouvons convertir ces données en objet <code>sf</code> avec la fonction <code>st_as_sf</code>. L’argument <code>coords</code> indique quelles colonnes contiennent les coordonnées X et Y, tandis que <code>crs</code> spécifie le système de coordonnées utilisé.</p>
<pre class="r"><code>plots &lt;- st_as_sf(plots, coords = c(&quot;long&quot;, &quot;lat&quot;), crs = st_crs(mrc))
plot(plots[&quot;geometry&quot;])</code></pre>
<p><img src="atelier_rgeo_files/figure-html/df_to_sf-1.png" width="672" /></p>
</div>
<div id="rappel" class="section level3">
<h3>Rappel</h3>
<ul>
<li>Les données spatiales vectorielles associent des champs de donnés à des objets géométriques tels que des points, lignes et polygones. Le package <strong><em>sf</em></strong> permet de travailler avec ces données dans R.</li>
<li>Pour lire un jeu de données vectoriel: <code>st_read</code>.</li>
<li>Pour convertir un jeu de données standard (<code>data.frame</code>) en objet spatial: <code>st_as_sf</code>.</li>
<li>Toutes les opérations de base des objets <code>data.frame</code>, ainsi que les fonctions du package <strong><em>dplyr</em></strong>, s’appliquent aussi aux objets <code>sf</code>.</li>
<li>La fonction <code>plot</code> appliquée à un objet <code>sf</code> permet d’afficher un ou plusieurs champs de données sur une carte.</li>
</ul>
<hr />
</div>
</div>
<div id="crs" class="section level2">
<h2>Systèmes de coordonnées et transformations</h2>
<p>Jusqu’à présent, nous avons travaillé avec des données utilisant un système de coordonnées géographiques, où les positions sont exprimées en degrés de longitude et latitude. Ces coordonnées sont basées sur un modèle qui approxime la surface irrégulière du niveau moyen de la mer autour de la Terre (appelée géoïde) par une ellipsoïde (une sphère légèrement aplatie). Ce modèle géodésique est le <em>datum</em> dans la description du système de coordonnées: les coordonnées de <code>mrc</code> sont définies avec le système NAD83 (Amérique du Nord), tandis que plusieurs cartes à l’échelle mondiale sont basées sur le système WGS84.</p>
<pre class="r"><code>st_crs(mrc)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: 4269 
##   wkt:
## GEOGCS[&quot;GCS_North_American_1983&quot;,
##     DATUM[&quot;North_American_Datum_1983&quot;,
##         SPHEROID[&quot;GRS_1980&quot;,6378137,298.257222101]],
##     PRIMEM[&quot;Greenwich&quot;,0],
##     UNIT[&quot;Degree&quot;,0.017453292519943295],
##     AUTHORITY[&quot;EPSG&quot;,&quot;4269&quot;]]</code></pre>
<p>Une projection convertit les coordonnées géographiques en coordonnées planes (X, Y). Puisqu’il est impossible de représenter fidèlement la surface entière du globe sur un plan, des projections spécialisées ont été développées en fonction de la région du monde et des besoins précis.</p>
<p>Par exemple, les images ci-dessous montrent comment des aires circulaires identiques à différents points du globe apparaissent sur une projection de Mercator (formes comparables) et sur une projection équivalente de Lambert (aires comparables).</p>
<p><img src="images/Mercator_distortion.png" alt="Projection de Mercator" /> <img src="images/Lambert_distortion.png" alt="Projection équivalente de Lambert" /></p>
<p>Nous allons convertir les polygones <code>mrc</code> dans une projection conique conforme de Lambert centrée sur le Québec (<a href="https://epsg.io/6622">code EPSG: 6622</a>), en utilisant la fonction <code>st_transform</code>.</p>
<pre class="r"><code>mrc_proj &lt;- st_transform(mrc, crs = 6622)
st_crs(mrc_proj)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: EPSG:6622 
##   wkt:
## PROJCS[&quot;NAD83(CSRS) / Quebec Lambert&quot;,
##     GEOGCS[&quot;NAD83(CSRS)&quot;,
##         DATUM[&quot;NAD83_Canadian_Spatial_Reference_System&quot;,
##             SPHEROID[&quot;GRS 1980&quot;,6378137,298.257222101,
##                 AUTHORITY[&quot;EPSG&quot;,&quot;7019&quot;]],
##             TOWGS84[0,0,0,0,0,0,0],
##             AUTHORITY[&quot;EPSG&quot;,&quot;6140&quot;]],
##         PRIMEM[&quot;Greenwich&quot;,0,
##             AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]],
##         UNIT[&quot;degree&quot;,0.0174532925199433,
##             AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]],
##         AUTHORITY[&quot;EPSG&quot;,&quot;4617&quot;]],
##     PROJECTION[&quot;Lambert_Conformal_Conic_2SP&quot;],
##     PARAMETER[&quot;standard_parallel_1&quot;,60],
##     PARAMETER[&quot;standard_parallel_2&quot;,46],
##     PARAMETER[&quot;latitude_of_origin&quot;,44],
##     PARAMETER[&quot;central_meridian&quot;,-68.5],
##     PARAMETER[&quot;false_easting&quot;,0],
##     PARAMETER[&quot;false_northing&quot;,0],
##     UNIT[&quot;metre&quot;,1,
##         AUTHORITY[&quot;EPSG&quot;,&quot;9001&quot;]],
##     AXIS[&quot;X&quot;,EAST],
##     AXIS[&quot;Y&quot;,NORTH],
##     AUTHORITY[&quot;EPSG&quot;,&quot;6622&quot;]]</code></pre>
<p>Les codes EPSG permettent de spécifier rapidement une projection. La description détaillée inclut le type de projection (<em>Lambert conforme conique</em>), des paramètres additionnels du type de projection, ainsi que les unités (mètres) pour les données projetées. Les coordonnées en mètres sont relatives à un point d’origine spécifié par les paramètres (<em>latitude_of_origin</em> et <em>central_meridian</em>).</p>
<pre class="r"><code>plot(mrc_proj[&quot;geometry&quot;], axes = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_geom_proj-1.png" width="672" /></p>
<p>On peut créer une carte montrant les lignes de latitude et longitude superposées aux données projetées, avec le paramètre <code>graticule</code> auquel on associe le système de coordonnées géographique des données originales:</p>
<pre class="r"><code>plot(mrc_proj[&quot;geometry&quot;], axes = TRUE, graticule = st_crs(mrc))</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_graticule-1.png" width="672" /></p>
<p>Il est important de toujours utiliser la fonction <code>st_transform</code> pour convertir des jeux de données entre différents système de coordonnées. Une erreur courante consiste à changer la définition du système de coordonnées (par exemple, avec la fonction<code>st_crs</code>) sans transformer les données elles-mêmes.</p>
<div id="rappel-1" class="section level3">
<h3>Rappel</h3>
<ul>
<li>Un système de coordonnées géographique est basé sur un modèle géodésique (<em>datum</em>) et donne la position en coordonnées sphériques (longitude, latitude) mesurées en degrés.</li>
<li>Un système de coordonnées projeté convertit les coordonnées sphériques en coordonnées planes (<em>x</em>, <em>y</em>) mesurées en mètres.</li>
<li><code>st_crs</code> indique le système de coordonnées d’un objet <code>sf</code>; <code>st_transform</code> convertit les coordonnées d’un système à un autre.</li>
</ul>
<hr />
</div>
</div>
<div id="geomsf" class="section level2">
<h2>Cartes détaillées avec ggplot2</h2>
<p>Bien que la fonction <code>plot</code> soit utile pour obtenir une vue d’ensemble d’un jeu de données spatial, d’autres packages offrent davantage d’options pour créer des cartes détaillées. Dans cette section, nous verrons comment un package populaire de graphiques en R, <strong><em>ggplot2</em></strong>, prend également en charge la cartographie de jeux de données spatiales.</p>
<p>Pour ceux qui ne connaissent pas <strong><em>ggplot2</em></strong>, une introduction complète est disponible dans le chapitre <a href="https://r4ds.had.co.nz/data-visualisation.html">Data visualisation</a> du livre <em>R for Data Science</em> (Wickham et Grolemund). Tous les graphiques <strong><em>ggplot2</em></strong> requièrent les mêmes étapes:</p>
<ul>
<li>Spécifier le jeu de données ainsi que les correspondances esthétiques (<code>aes</code>), qui associent les variables du jeu de données à des éléments graphiques (axes <em>x</em> et <em>y</em>, échelle de couleur ou de taille, etc.);</li>
<li>Ajouter les couches <code>geom_</code>, qui spécifient le type de graphique;</li>
<li>Au besoin, spécifier des options de personnalisation supplémentaires, telles que les noms et limites d’axes, les thèmes de couleur, etc.</li>
</ul>
<p>Par exemple, le code suivant crée un graphique en barres (<code>geom_bar</code>) à partir des données de parcelles d’inventaire forestier (<code>data = plots</code>), indiquant le nombre de parcelles forestières par classe de hauteur (axe <em>x</em>) et par type de couverture (<em>fill</em>, remplissage des barres). La fonction <code>labs</code> définit des titres personnalisés pour le graphique, les axes et la légende.</p>
<pre class="r"><code>library(ggplot2)

ggplot(data = plots, aes(x = height_cls, fill = cover_type)) + 
    geom_bar() +
    labs(title = &quot;Forest inventory plots&quot;, x = &quot;Height class&quot;, 
         y = &quot;Count&quot;, fill = &quot;Cover type&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/ggplot_bar-1.png" width="672" /></p>
<p>Lorsque le jeu de données est un objet <code>sf</code>, nous utilisons la fonction <code>geom_sf</code> pour afficher les éléments géométriques sur une carte. Il n’est pas nécessaire de spécifier les correspondances <em>x</em> et <em>y</em> dans <code>aes</code>, car celles-ci sont définies par l’objet <code>sf</code> lui-même. Les lignes du graticule sont dessinées automatiquement.</p>
<pre class="r"><code>ggplot(data = mrc_proj) +
    geom_sf()</code></pre>
<p><img src="atelier_rgeo_files/figure-html/geom_sf-1.png" width="672" /></p>
<p>Pour ajouter plusieurs couches spatiales à la même carte, nous ajoutons simplement plusieurs <code>geom_sf</code>, qui peuvent être basés sur différents jeux de données (en spécifiant l’argument <code>data</code> dans chaque <code>geom</code>). Dans le code ci-dessous, nous ajoutons une couche de points pour les placettes d’inventaire forestier, en attribuant l’esthétique de la couleur au type de couvert. Nous utilisons <code>theme_set(theme_bw())</code> pour remplacer le thème gris par défaut par un thème en noir et blanc pour tous les graphiques subséquents.</p>
<pre class="r"><code>theme_set(theme_bw())
ggplot() +
    geom_sf(data = mrc_proj) +
    geom_sf(data = plots, aes(color = cover_type), size = 1)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/geom_sf_mult-1.png" width="672" /></p>
<p>Lorsqu’un élément graphique est défini comme une constante en dehors de la fonction <code>aes</code>, il s’applique à toute la couche; donc <code>size = 1</code> indique que tous les points sont de taille 1.</p>
<p>Remarquez que les deux jeux de données utilisent des systèmes de coordonnées différents:</p>
<pre class="r"><code>st_crs(mrc_proj)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: EPSG:6622 
##   wkt:
## PROJCS[&quot;NAD83(CSRS) / Quebec Lambert&quot;,
##     GEOGCS[&quot;NAD83(CSRS)&quot;,
##         DATUM[&quot;NAD83_Canadian_Spatial_Reference_System&quot;,
##             SPHEROID[&quot;GRS 1980&quot;,6378137,298.257222101,
##                 AUTHORITY[&quot;EPSG&quot;,&quot;7019&quot;]],
##             TOWGS84[0,0,0,0,0,0,0],
##             AUTHORITY[&quot;EPSG&quot;,&quot;6140&quot;]],
##         PRIMEM[&quot;Greenwich&quot;,0,
##             AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]],
##         UNIT[&quot;degree&quot;,0.0174532925199433,
##             AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]],
##         AUTHORITY[&quot;EPSG&quot;,&quot;4617&quot;]],
##     PROJECTION[&quot;Lambert_Conformal_Conic_2SP&quot;],
##     PARAMETER[&quot;standard_parallel_1&quot;,60],
##     PARAMETER[&quot;standard_parallel_2&quot;,46],
##     PARAMETER[&quot;latitude_of_origin&quot;,44],
##     PARAMETER[&quot;central_meridian&quot;,-68.5],
##     PARAMETER[&quot;false_easting&quot;,0],
##     PARAMETER[&quot;false_northing&quot;,0],
##     UNIT[&quot;metre&quot;,1,
##         AUTHORITY[&quot;EPSG&quot;,&quot;9001&quot;]],
##     AXIS[&quot;X&quot;,EAST],
##     AXIS[&quot;Y&quot;,NORTH],
##     AUTHORITY[&quot;EPSG&quot;,&quot;6622&quot;]]</code></pre>
<pre class="r"><code>st_crs(plots)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: 4269 
##   wkt:
## GEOGCS[&quot;GCS_North_American_1983&quot;,
##     DATUM[&quot;North_American_Datum_1983&quot;,
##         SPHEROID[&quot;GRS_1980&quot;,6378137,298.257222101]],
##     PRIMEM[&quot;Greenwich&quot;,0],
##     UNIT[&quot;Degree&quot;,0.017453292519943295],
##     AUTHORITY[&quot;EPSG&quot;,&quot;4269&quot;]]</code></pre>
<p>Dans ce cas, <strong><em>ggplot2</em></strong> transforme automatiquement toutes les couches en un même CRS. Par défaut, il s’agit du CRS du premier jeu de données, mais un autre CRS peut être spécifié avec la fonction <code>coord_sf</code>.</p>
<pre class="r"><code>ggplot(data = plots) +
    geom_sf() +
    coord_sf(crs = 6622)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/ggplot_crs-1.png" width="672" /></p>
<p>De plus, <code>coord_sf</code> peut servir à choisir les limites de chaque axe, pour “zoomer” sur une portion de la carte.</p>
<pre class="r"><code>ggplot(data = regions) +
    geom_sf(aes(fill = pop2016)) +
    geom_sf_label(aes(label = reg_name)) +
    coord_sf(xlim = c(-75, -70), ylim = c(45, 47))</code></pre>
<pre><code>## Warning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not
## give correct results for longitude/latitude data</code></pre>
<p><img src="atelier_rgeo_files/figure-html/coord_sf-1.png" width="672" /></p>
<p>Ce dernier exemple présente un nouveau geom <code>geom_sf_label</code>, qui ajoute une étiquette de texte à chaque entité en fonction d’une valeur définie par l’élément <code>label</code>. <code>geom_sf_text</code> est semblable, mais omet le rectangle blanc autour de l’étiquette de texte.</p>
<div id="retour2" class="section level3">
<h3>Exercice 2</h3>
<p>Créez une carte des MRC avec des couleurs de remplissage différentes pour chaque région.</p>
<p><a href="#sol2">Solution</a></p>
</div>
<div id="rappel-2" class="section level3">
<h3>Rappel</h3>
<ul>
<li>Un graphique <strong><em>ggplot2</em></strong> commence par un appel à la fonction <code>ggplot()</code>, suivi d’un <code>geom</code> spécifique définissant chaque couche du graphique, suivi optionnellement de fonctions de personnalisation.</li>
<li>L’argument <code>data</code> spécifie un jeu de données et la fonction <code>aes</code> associe les variables de ce jeu de données à des éléments graphiques. Ces arguments peuvent être définis dans la fonction <code>ggplot</code> (s’ils s’appliquent à toutes les couches) ou dans des couches <code>geom</code> spécifiques.</li>
<li>La couche <code>geom_sf</code> ajoute les objets <code>sf</code> sur une carte.</li>
<li>Les couches <code>geom_sf_text</code> ou<code>geom_sf_label</code> ajoutent des données textuelles à chaque entité spatiale d’une carte.</li>
<li>La fonction <code>coord_sf</code> définit les limites des axes et le CRS à utiliser, transformant toutes les entités spatiales dans ce CRS. Par défaut, le CRS du premier jeu de données spatial est utilisé.</li>
</ul>
</div>
<div id="autres-packages-pour-les-cartes" class="section level3">
<h3>Autres packages pour les cartes</h3>
<p>Le package <strong><em>tmap</em></strong> (voir <a href="https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html">ce tutoriel</a>) permet aussi de produire des cartes dans R. Il a été développé avant que <strong><em>ggplot2</em></strong> ne prenne en charge les objets <code>sf</code> et sa syntaxe ressemble à celle de <strong><em>ggplot2</em></strong>.</p>
<hr />
</div>
</div>
<div id="vectop" class="section level2">
<h2>Opérations géométriques sur les données vectorielles</h2>
<p>Le package <strong><em>sf</em></strong> inclut un certain nombre d’opérations géométriques pour les données vectorielles, similaires à celles des bases de données géographiques ou des logiciels SIG. Ces opérations peuvent être regroupées en trois classes:</p>
<ul>
<li>des prédicats ou tests, dont la sortie est TRUE/FALSE (ex.: la géométrie A est-elle contenue dans B?);</li>
<li>des mesures, qui produisent une quantité scalaire (par exemple, la longueur d’une ligne, l’aire d’un polygone, la distance entre deux géométries);</li>
<li>des fonctions génératrices de géométries qui produisent des géométries en sortie basées sur l’entrée (par exemple, distance tampon autour d’un point, centroïde d’un polygone, intersection de deux lignes ou polygones).</li>
</ul>
<p>Dans cet atelier, nous présenterons quelques exemples de chaque classe. Pour une présentation plus détaillée, voir le chapitre 5 du livre <em>Spatial Data Science</em> figurant dans les <a href="#ref">références supplémentaires</a>.</p>
<p>Tout d’abord, nous utilisons <code>st_area</code> pour calculer la surface de chaque MRC dans le jeu de données original.</p>
<pre class="r"><code>areas &lt;- st_area(mrc)
head(areas)</code></pre>
<pre><code>## Units: [m^2]
## [1]   7940855145   3630423258    582240572 513075556998  16304017180
## [6]   1335860444</code></pre>
<p>Notez que la réponse est exprimée en mètres carrés, même si <code>mrc</code> utilise des coordonnées géographiques. Trois fonctions de mesure: <code>st_area</code>,<code>st_length</code> et <code>st_distance</code> implémentent des mesures géodésiques qui prennent en compte la courbure de la Terre. Ce n’est pas le cas pour d’autres opérations, comme nous le verrons plus loin.</p>
<p>Pour faciliter la lecture des résultats, nous pouvons les convertir en une unité différente.</p>
<pre class="r"><code>units(areas) &lt;- &quot;km^2&quot;
head(areas)</code></pre>
<pre><code>## Units: [km^2]
## [1]   7940.8551   3630.4233    582.2406 513075.5570  16304.0172   1335.8604</code></pre>
<p>Comme exemple de prédicat, vérifions quels points dans <code>plots</code> ont une intersection (un point en commun) avec des polygones dans <code>mrc</code>.</p>
<pre class="r"><code>inters &lt;- st_intersects(plots, mrc)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar
## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>inters[1:3] # regarder les trois premiers éléments</code></pre>
<pre><code>## [[1]]
## [1] 94
## 
## [[2]]
## [1] 94
## 
## [[3]]
## [1] 53</code></pre>
<p>Lorsque l’on compare deux objets spatiaux avec un prédicat tel que <code>st_intersects</code>, le résultat est une liste de la même longueur que le premier objet (ici,<code>plots</code>). Chaque élément de cette liste contient les indices des éléments du deuxième objet pour lequel le prédicat est vrai. Dans cet exemple, le premier élément de la liste (<code>[[1]]</code>) indique que la parcelle 1 intersecte avec la MRC 94, le troisième élément indique que la parcelle 3 intersecte avec la MRC 53, etc. Ici, chaque parcelle intersecte avec une seule MRC, mais en général, un élément de l’intersection peut être vide (si cet élément du premier objet n’a pas d’intersection avec le second objet) ou contenir plusieurs indices (si cet élément chevauche plusieurs éléments dans l’objet 2).</p>
<p>Le texte d’avertissement:</p>
<p>“although coordinates are longitude/latitude, st_intersects assumes that they are planar”,</p>
<p>indique que cette fonction traite les coordonnées géographiques comme s’il s’agissait de coordonnées X-Y sur un plan. En particulier, les limites d’un polygone ne sont pas les lignes les plus courtes entre ses sommets, car elles ignorent la courbure de la Terre. La différence est généralement mineure, à moins que les segments de ligne soient très longs, s’ils soient proches d’un pôle ou de la ligne internationale de changement de date (où la longitude passe de -180 à 180 degrés).</p>
<p>À partir des résultats de <code>st_intersects</code> ci-dessus, nous pourrions suivre les indices pour trouver le nom de la MRC dans laquelle se trouve chaque parcelle d’inventaire. Heureusement, il existe une fonction de jonction spatiale <code>st_join</code> qui automatise ce processus en ajoutant à un objet<code>sf</code> les champs de données d’un deuxième objet <code>sf</code> lorsqu’il y a intersection entre les éléments.</p>
<pre class="r"><code>plots_mrc &lt;- st_join(plots, mrc)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar
## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>head(plots_mrc)</code></pre>
<pre><code>## Simple feature collection with 6 features and 8 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -72.8958 ymin: 45.35944 xmax: -71.1618 ymax: 45.49196
## CRS:            4269
##    plot_id  surv_date cover_type height_cls               mrc_name reg_id
## 1 99100101 2012-11-12  Deciduous    17-22 m               Rouville     16
## 2 99100102 2012-09-08  Deciduous      &gt;22 m               Rouville     16
## 3 99100201 2008-09-11  Deciduous    17-22 m Le Haut-Saint-Francois     05
## 4 99100202 2008-09-11  Deciduous    17-22 m Le Haut-Saint-Francois     05
## 5 99100301 2012-08-30  Deciduous      &gt;22 m       La Haute-Yamaska     16
## 6 99100302 2012-08-30  Deciduous      &gt;22 m       La Haute-Yamaska     16
##     reg_name pop2016                   geometry
## 1 Monteregie   36724  POINT (-72.8958 45.35944)
## 2 Monteregie   36724 POINT (-72.89244 45.36267)
## 3     Estrie   22376 POINT (-71.16727 45.49196)
## 4     Estrie   22376  POINT (-71.1618 45.49068)
## 5 Monteregie   88683 POINT (-72.58792 45.47711)
## 6 Monteregie   88683 POINT (-72.58448 45.47969)</code></pre>
<p>Par défaut, <code>st_join</code> effectue une jonction “à gauche”, c’est-à-dire qu’elle conserve toutes les rangées du premier jeu de données, ajoutant des valeurs manquantes <em>NA</em> pour les champs additionnels lorsqu’il n’y a pas d’intersection avec le deuxième jeu de données. Nous pouvons constater cela en faisant la jonction de <code>plots</code> avec les MRC des régions 01 et 11 (voir Exercice 1).</p>
<pre class="r"><code>mrc_01_11 &lt;- mrc[mrc$reg_id %in% c(&quot;01&quot;, &quot;11&quot;), ]
plots_01_11 &lt;- st_join(plots, mrc_01_11)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar
## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>head(plots_01_11)</code></pre>
<pre><code>## Simple feature collection with 6 features and 8 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -72.8958 ymin: 45.35944 xmax: -71.1618 ymax: 45.49196
## CRS:            4269
##    plot_id  surv_date cover_type height_cls mrc_name reg_id reg_name pop2016
## 1 99100101 2012-11-12  Deciduous    17-22 m     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;      NA
## 2 99100102 2012-09-08  Deciduous      &gt;22 m     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;      NA
## 3 99100201 2008-09-11  Deciduous    17-22 m     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;      NA
## 4 99100202 2008-09-11  Deciduous    17-22 m     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;      NA
## 5 99100301 2012-08-30  Deciduous      &gt;22 m     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;      NA
## 6 99100302 2012-08-30  Deciduous      &gt;22 m     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;      NA
##                     geometry
## 1  POINT (-72.8958 45.35944)
## 2 POINT (-72.89244 45.36267)
## 3 POINT (-71.16727 45.49196)
## 4  POINT (-71.1618 45.49068)
## 5 POINT (-72.58792 45.47711)
## 6 POINT (-72.58448 45.47969)</code></pre>
<p>Avec l’argument optionnel <code>left = FALSE</code>, nous conservons seulement les placettes situées dans les deux régions voulues.</p>
<pre class="r"><code>mrc_01_11 &lt;- mrc[mrc$reg_id %in% c(&quot;01&quot;, &quot;11&quot;), ]
plots_01_11 &lt;- st_join(plots, mrc_01_11, left = FALSE)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar
## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>ggplot() +
    geom_sf(data = mrc_01_11) +
    geom_sf(data = plots_01_11)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/st_join_inner-1.png" width="672" /></p>
<div id="retour3" class="section level3">
<h3>Exercice 3</h3>
<p>Le fichier <em>data/tbe2016_gaspe.shp</em> contient une carte des régions défoliées par la tordeuse des bourgeons de l’épinette au Bas-St-Laurent et en Gaspésie en 2016. Le niveau de défoliation est représenté par un entier: 1 = léger, 2 = modéré et 3 = sévère.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Combien de placettes dans ces régions sont affectées à chaque niveau de défoliation? <em>Indice</em>: La fonction <code>table</code> est utile pour compter les effectifs de chaque valeur dans une colonne.</p></li>
<li><p>Produisez une carte des régions défoliées situées dans la MRC de Kamouraska, avec les limites de la MRC.</p></li>
</ol>
<p><a href="#sol3">Solution</a></p>
<p>Enfin, considérons quelques fonctions génératrices de géométries. La fonction <code>st_buffer</code> crée une zone tampon à une distance définie de chaque élément d’un objet. Par exemple, nous pouvons définir un rayon de 5 km autour de chaque point dans <code>plots_01_11</code>. Cette fonction ne fonctionne pas avec les coordonnées géographiques (longitude et latitude), nous projetons donc d’abord les points en coordonnées EPSG 6622. La distance de tampon est définie dans les unités du CRS, ici en mètres.</p>
<pre class="r"><code>plots_proj &lt;- st_transform(plots_01_11, crs = 6622)
plots_buffer &lt;- st_buffer(plots_proj, dist = 5000)

ggplot() +
    geom_sf(data = plots_buffer, linetype = &quot;dotted&quot;, fill = NA) +
    geom_sf(data = plots_proj)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/st_buffer-1.png" width="672" /></p>
<p>Si la couche originale est formée de polygones, une distance négative crée une zone tampon à l’intérieur des polygones.</p>
<pre class="r"><code>mrc_01_11_proj &lt;- st_transform(mrc_01_11, crs = 6622)
mrc_buffer &lt;- st_buffer(mrc_01_11_proj, dist = -5000)

ggplot() +
    geom_sf(data = mrc_buffer, linetype = &quot;dotted&quot;, fill = NA) +
    geom_sf(data = mrc_01_11_proj, fill = NA)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/st_buffer_neg-1.png" width="672" /></p>
<p>Ensuite, nous verrons trois fonctions basées sur des opérations d’ensembles. Si <em>A</em> et <em>B</em> sont des éléments géométriques, leur union est la zone couverte par A ou B, leur intersection est la zone couverte par A et B, et la différence (A - B) est la zone couverte par A, mais pas B. Dans <code>sf</code>, ces opérations sont réalisées par<code>st_union</code>, <code>st_intersection</code> et<code>st_difference</code>.</p>
<p>Si elles sont appliquées à deux objets <code>sf</code> (chacun d’entre eux contenant plusieurs éléments dans une colonne), alors la fonction calcule l’union, l’intersection ou la différence entre toutes les paires possibles d’un élément de A et d’un élément de B. Appliquée à un seul objet <code>sf</code>, la fonction<code>st_union</code> fusionne tous les éléments de cet objet.</p>
<p>Dans l’exemple suivant, <code>buffer_union</code> est un objet géométrique unique, un multipolygone qui couvre toutes les zones tampons des polygones des MRC individuelles. Les variables, ou attributs, associées à des éléments individuels sont perdues lors de la fusion.</p>
<pre class="r"><code>buffer_union &lt;- st_union(mrc_buffer)

ggplot(buffer_union) +
    geom_sf()</code></pre>
<p><img src="atelier_rgeo_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Nous pouvons ensuite utiliser <code>st_difference</code> pour extraire 5 km de “bordure” de chaque polygone qui se trouve en dehors de la zone tampon fusionnée.</p>
<pre class="r"><code>mrc_edge &lt;- st_difference(mrc_01_11_proj, buffer_union)</code></pre>
<pre><code>## Warning: attribute variables are assumed to be spatially constant throughout all
## geometries</code></pre>
<pre class="r"><code>ggplot(mrc_edge) +
    geom_sf()</code></pre>
<p><img src="atelier_rgeo_files/figure-html/st_diff-1.png" width="672" /></p>
<p>Notez que <code>st_difference</code> copient les champs des jeux de données d’origine (ici, uniquement à partir de <code>mrc_01_11_proj</code>, car<code>buffer_union</code> n’a aucune donnée associée). L’avertissement (“attribute variables are assumed to be spatially constant”) nous rappelle que ces variables pourraient ne pas correspondre aux nouvelles géométries. Par exemple, la variable <em>pop2016</em> dans <code>mrc_inters</code> fait référence à la MRC d’origine et non à la partie extraite par <code>st_difference</code>.</p>
</div>
<div id="rappel-3" class="section level3">
<h3>Rappel</h3>
<ul>
<li>Le package <strong><em>sf</em></strong> inclut des fonctions de mesure pour l’aire des polygones (<code>st_area</code>), la longueur d’une ligne (<code>st_length</code>) ou la distance entre des paires d’éléments géométriques (<code>st_distance</code>). Ces fonctions sont adaptées aux systèmes de coordonnées géographiques (long, lat) ou projetés.</li>
<li>Toutes les autres opérations géométriques dans <strong><em>sf</em></strong> sont basées sur la géométrie plane. Elles traitent la longitude et la latitude comme s’il s’agissait d’axes perpendiculaires (x, y).</li>
<li><code>st_intersects (A, B)</code> est un exemple de <em>prédicat</em> spatial: pour chaque élément de <em>A</em>, la fonction renvoie les indices des éléments de <em>B</em> qui l’intersectent.</li>
<li><code>st_join (A, B)</code> prend un objet <code>sf</code> <em>A</em> et y ajoute les champs de données d’un second objet <em>B</em> pour chaque cas où l’élément de <em>A</em> intersecte avec un élément de <em>B</em>. Contrairement à <code>st_intersection</code> ci-dessous, les éléments géométriques eux-mêmes ne changent pas; le résultat conserve la géométrie de <em>A</em>.</li>
<li><code>st_intersection (A, B)</code> produit un jeu de données contenant toutes les régions où les éléments de <em>A</em> et <em>B</em> se chevauchent.</li>
<li><code>st_difference (A, B)</code> produit un jeu de données contenant la différence d’ensemble (zones couvertes par <em>A</em>, mais pas par <em>B</em>) pour chaque paires d’éléments de <em>A</em> et <em>B</em>.</li>
<li><code>st_union (A, B)</code> produit un jeu de données contenant les unions (zone couverte par <em>A</em> ou <em>B</em>) pour chaque paire d’éléments d’<em>A</em> et <em>B</em>. Lorsqu’un seul objet <code>sf</code> est fourni en entrée, <code>st_union</code> fusionne tous les éléments de cet objet en un seul.</li>
<li><code>st_buffer</code> produit de nouveaux éléments géométriques qui ajoutent un tampon d’une distance donnée autour des géométries originales.</li>
</ul>
<hr />
</div>
</div>
<div id="rast" class="section level2">
<h2>Traitement des données matricielles</h2>
<p>Le dossier <em>data</em> contient un fichier couvrant les sections 022B et 022C du <a href="https://ouvert.canada.ca/data/fr/dataset/7f245e4d-76c2-4caa-951a-45d1d2051333">Modèle numérique d’élévation canadien</a> ou CDEM.</p>
<p>Le CDEM est un jeu de données matriciel; la superficie Canada est couverte par une grille régulière et le modèle associe une valeur d’élévation (en mètres) à chaque pixel de cette grille. Ce type de données est analogue à une image numérique (matrice rectangulaire de pixels), à laquelle sont ajoutées des métadonnées (résolution, étendue spatiale et système de coordonnées), de sorte que chaque pixel puisse être associé à des coordonnées géographiques.</p>
<p>La résolution de base du CDEM est de 1/4800 de degré et les données sont disponibles en sections de 2 degrés de longitude par 1 degré de latitude. Le fichier de données que nous utilisons dans cet atelier contient deux sections (4 degrés de longitude sur 1 degré de latitude), mais sa résolution a été réduite (1/1200 de degré ou 3 secondes d’arc) pour réduire le temps de traitement.</p>
<p>Nous chargeons d’abord le fichier CDEM, qui est en format GeoTIFF, avec la fonction <code>read_stars</code> du package <strong><em>stars</em></strong> (le nom est l’acronyme de <em>spatiotemporal arrays</em>). Cette fonction associe le jeu de données à un objet <code>stars</code>. En tapant le nom de l’objet sur la ligne de commande, vous obtenez un résumé des données et des métadonnées.</p>
<pre class="r"><code>library(stars)
cdem &lt;- read_stars(&quot;data/cdem_022BC_3s.tif&quot;)
cdem</code></pre>
<pre><code>## stars object with 2 dimensions and 1 attribute
## attribute(s), summary of first 1e+05 cells:
##  cdem_022BC_3s.tif 
##  Min.   :   2.0    
##  1st Qu.:   2.0    
##  Median : 129.1    
##  Mean   : 189.8    
##  3rd Qu.: 328.8    
##  Max.   :1179.4    
## dimension(s):
##   from   to   offset        delta                       refsys point values    
## x    1 4801 -70.0001  0.000833333 GEOGCS[&quot;NAD83&quot;,DATUM[&quot;Nor... FALSE   NULL [x]
## y    1 1201  49.0001 -0.000833333 GEOGCS[&quot;NAD83&quot;,DATUM[&quot;Nor... FALSE   NULL [y]</code></pre>
<p>Les données CDEM ont un <em>attribut</em> (variable), l’élévation, qui varie de 2 à 1179 m pour cette section. Le tableau <em>dimensions</em> comprend une ligne pour chaque dimension de tableau, ici <em>x</em> et <em>y</em>. Les colonnes <em>from</em> et <em>to</em> indiquent la plage d’indices dans chaque dimension (4801 cellules en <em>x</em>, 1201 cellules en <em>y</em>), la colonne <em>offset</em> contient les coordonnées du coin supérieur gauche du raster (70 degrés Ouest, 49 degrés Nord), la colonne <em>delta</em> indique la taille de chaque cellule (1/1200 soit environ 0,000833 degrés) et la colonne <em>refsys</em> décrit le système de coordonnées.</p>
<p><em>Notes</em></p>
<ul>
<li><p>Le <em>delta</em> négatif pour <em>y</em> signifie que la latitude décroît du haut (nord) au bas (sud) de l’image.</p></li>
<li><p>Bien que nous nous limitions aux rasters bidimensionnels dans cet atelier, l’un des avantages du package <strong><em>stars</em></strong> est qu’il intègre facilement des dimensions supplémentaires non-spatiales, telles que le temps ou la bande spectrale, qui apparaissent couramment dans données de télédétection.</p></li>
</ul>
<p>Nous pouvons également déterminer l’étendue et le système de coordonnées de l’objet avec les mêmes méthodes que nous avons utilisées pour les objets <code>sf</code>.</p>
<pre class="r"><code>st_bbox(cdem)</code></pre>
<pre><code>##      xmin      ymin      xmax      ymax 
## -70.00010  47.99927 -65.99927  49.00010</code></pre>
<pre class="r"><code>st_crs(cdem)</code></pre>
<pre><code>## Coordinate Reference System:
##   User input: GEOGCS[&quot;NAD83&quot;,DATUM[&quot;North_American_Datum_1983&quot;,SPHEROID[&quot;GRS 1980&quot;,6378137,298.2572221010042,AUTHORITY[&quot;EPSG&quot;,&quot;7019&quot;]],TOWGS84[0,0,0,0,0,0,0],AUTHORITY[&quot;EPSG&quot;,&quot;6269&quot;]],PRIMEM[&quot;Greenwich&quot;,0],UNIT[&quot;degree&quot;,0.0174532925199433],AUTHORITY[&quot;EPSG&quot;,&quot;4269&quot;]] 
##   wkt:
## GEOGCS[&quot;NAD83&quot;,
##     DATUM[&quot;North_American_Datum_1983&quot;,
##         SPHEROID[&quot;GRS 1980&quot;,6378137,298.2572221010042,
##             AUTHORITY[&quot;EPSG&quot;,&quot;7019&quot;]],
##         TOWGS84[0,0,0,0,0,0,0],
##         AUTHORITY[&quot;EPSG&quot;,&quot;6269&quot;]],
##     PRIMEM[&quot;Greenwich&quot;,0],
##     UNIT[&quot;degree&quot;,0.0174532925199433],
##     AUTHORITY[&quot;EPSG&quot;,&quot;4269&quot;]]</code></pre>
<p>Nous pouvons extraire les valeurs d’élévation dans une matrice R régulière avec <code>cdem[[1]]</code>, qui extrait la première (ici, la seule) variable du fichier. Cependant, nous perdons ainsi les métadonnées.</p>
<pre class="r"><code>elev &lt;- cdem[[1]]
str(elev)</code></pre>
<pre><code>##  num [1:4801, 1:1201] 599 607 610 612 612 ...</code></pre>
<div id="visualiser-des-données-matricielles" class="section level3">
<h3>Visualiser des données matricielles</h3>
<p>La fonction <code>plot</code> crée une image 2D rapide d’un jeu de données matricielles.</p>
<pre class="r"><code>plot(cdem)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_stars-1.png" width="672" /></p>
<p>Nous pouvons également afficher un objet <code>stars</code> dans un graphique <strong><em>ggplot2</em></strong> avec la fonction <code>geom_stars</code>. Puisque le nombre de pixels de la couche peut être bien supérieur à la résolution de l’écran, il est utile d’appliquer un facteur de sous-échantillonnage (<em>downsample</em>) pour accélérer la visualisation. Ici, <code>downsample = 5</code> signifie qu’un pixel sur 5 est affiché.</p>
<pre class="r"><code>ggplot() +
    geom_stars(data = cdem, downsample = 5) +
    geom_sf(data = mrc_01_11, color = &quot;white&quot;, fill = NA) +
    scale_fill_viridis_c() +
    coord_sf(xlim = c(-70, -66), ylim = c(48, 49))</code></pre>
<p><img src="atelier_rgeo_files/figure-html/geom_stars-1.png" width="672" /></p>
<p>La fonction <code>plot</code> ci-dessus sous-échantillonne automatiquement les données en fonction de la résolution de l’écran.</p>
</div>
<div id="travailler-avec-des-fichiers-volumineux" class="section level3">
<h3>Travailler avec des fichiers volumineux</h3>
<p>Pour les fichiers matriciels trop volumineux pour être chargés en mémoire, vous pouvez utiliser l’argument <code>proxy = TRUE</code> dans<code>read_stars</code>. Dans ce cas, R charge un objet <code>stars_proxy</code> contenant les métadonnées, mais pas les valeurs des pixels. Toutes les opérations matricielles peuvent également être appliquées aux objets <code>stars_proxy</code>, mais les calculs ne sont effectués que lorsque le résultat est affiché (dans ce cas, les pixels sont sous-échantillonnés) ou lorsque l’objet est enregistré sur le disque (avec <code>write_stars</code>).</p>
</div>
<div id="opérations-matricielles" class="section level3">
<h3>Opérations matricielles</h3>
<p>Pour couper une section rectangulaire de l’image, nous pouvons utiliser la fonction <code>filter</code> de <strong><em>dplyr</em></strong> le long d’une ou de plusieurs dimensions. Par exemple, voici la partie des données CDEM à l’est de 67 degrés Ouest.</p>
<pre class="r"><code>cdem_part &lt;- filter(cdem, x &gt; -67)
plot(cdem_part)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Pour couper les données le long des limites d’un objet <code>sf</code>, nous utilisons la fonction <code>st_crop</code>. Le code suivant montre l’élévation des points dans la MRC de La Mitis. Notez que nous avons converti le polygone dans le CRS du raster avant le découpage.</p>
<pre class="r"><code>mitis &lt;- filter(mrc_01_11, mrc_name == &quot;La Mitis&quot;)
mitis &lt;- st_transform(mitis, st_crs(cdem))
cdem_mitis &lt;- st_crop(cdem, mitis)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>plot(cdem_mitis)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/st_crop-1.png" width="672" /></p>
<p>Puisque les objets <code>stars</code> sont à la base des matrices de valeurs, les opérations mathématiques de R s’y appliquent pixel par pixel, comme pour une matrice régulière.</p>
<pre class="r"><code># Élévation en km
cdem_km &lt;- cdem / 1000
plot(cdem_km)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/raster_math-1.png" width="672" /></p>
<pre class="r"><code># Points dont l&#39;élévation est &gt;500 m
cdem_500 &lt;- cdem &gt; 500
plot(cdem_500)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/raster_math-2.png" width="672" /></p>
</div>
<div id="retour4" class="section level3">
<h3>Exercice 4</h3>
<ol style="list-style-type: lower-alpha">
<li><p>Affichez une carte montrant à quels endroits l’élévation est entre 5 et 100 m dans la MRC de La Mitis.</p></li>
<li><p>Quel est la plus grande valeur d’élévation dans cette MRC?</p></li>
</ol>
<p><a href="#sol4">Solution</a></p>
</div>
<div id="extraire-les-valeurs-à-partir-de-points" class="section level3">
<h3>Extraire les valeurs à partir de points</h3>
<p>Il est fréquent de vouloir extraire des valeurs d’une couche matricielle à l’emplacement de points d’intérêt. Par exemple, nous pourrions avoir besoin des valeurs d’élévation pour chaque parcelle d’inventaire forestier dans <code>plots_01_11</code>.</p>
<p>Comme le package <strong><em>stars</em></strong> ne dispose pas d’option rapide pour l’extraction de points, nous allons utiliser le package <strong><em>raster</em></strong> et sa fonction <code>extract</code>.</p>
<pre class="r"><code>library(raster)
cdem_r &lt;- as(cdem, &quot;Raster&quot;) # convertir en format raster
plots_elev &lt;- extract(cdem_r, plots_01_11)

plots_01_11$elev &lt;- plots_elev # ajouter une colonne à l&#39;objet sf

head(plots_01_11)</code></pre>
<pre><code>## Simple feature collection with 6 features and 9 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -67.02499 ymin: 48.36367 xmax: -64.41216 ymax: 48.52901
## CRS:            4269
##      plot_id  surv_date cover_type height_cls        mrc_name reg_id
## 17 119600101 2016-06-16 Coniferous    17-22 m     Bonaventure     11
## 18 119600102 2016-06-16 Coniferous    17-22 m     Bonaventure     11
## 19 119600201 2015-06-03 Coniferous    12-17 m    La Matapedia     01
## 20 119600202 2015-06-03 Coniferous    12-17 m    La Matapedia     01
## 21 119600301 2016-06-15 Coniferous    12-17 m Le Rocher-Perce     11
## 22 119600302 2016-06-14 Coniferous    12-17 m Le Rocher-Perce     11
##                           reg_name pop2016                   geometry     elev
## 17 Gaspesie - Iles-de-la-Madeleine   17664  POINT (-65.43818 48.3653)       NA
## 18 Gaspesie - Iles-de-la-Madeleine   17664 POINT (-65.43293 48.36367)       NA
## 19               Bas-Saint-Laurent   17935 POINT (-67.02499 48.36973) 453.1875
## 20               Bas-Saint-Laurent   17935 POINT (-67.02246 48.37316) 435.1875
## 21 Gaspesie - Iles-de-la-Madeleine   17311 POINT (-64.41546 48.52901)       NA
## 22 Gaspesie - Iles-de-la-Madeleine   17311  POINT (-64.41216 48.5262)       NA</code></pre>
</div>
<div id="rappel-4" class="section level3">
<h3>Rappel</h3>
<ul>
<li>Un jeu de données matricielles associe une valeur à chaque pixel d’une grille régulière. Le package <strong><em>stars</em></strong> nous permet de traiter ce type de données en R.</li>
<li>La fonction <code>read_stars</code> charge un fichier matriciel dans R. Pour les fichiers volumineux, spécifiez <code>proxy = TRUE</code> pour éviter de charger le raster complet en mémoire.</li>
<li>L’objet <code>stars</code> peut être affiché par lui-même avec <code>plot</code>, ou être ajouté à un graphique <code>ggplot</code> avec <code>geom_stars</code>.</li>
<li><code>filter</code> coupe un objet <code>stars</code> selon les valeurs spécifiées pour chaque dimension, tandis que <code>st_crop</code> le découpe dans les limites d’un objet <code>sf</code>.</li>
<li>Les opérateurs arithmétiques (<code>+</code>, <code>-</code>, etc.) et de comparaison (<code>&lt;</code>, <code>==</code>, etc.) sont appliqués à chaque pixel de l’objet <code>stars</code>.</li>
<li>La fonction <code>extract</code> du package <strong><em>raster</em></strong> extrait les valeurs matricielles pour des points spécifiés par un objet <code>sf</code>.</li>
</ul>
<hr />
</div>
</div>
<div id="mapview" class="section level2">
<h2>Cartes interactives avec mapview</h2>
<p>Le package <strong><em>mapview</em></strong> permet de visualiser des objets <code>sf</code> ou <code>stars</code> sur une carte interactive (de style Google Maps), avec différentes options de couche de base (ex.: OpenStreetMap, OpenTopoMap, World Imagery d’ESRI). Il suffit d’appeler la fonction <code>mapview</code> avec le nom de l’objet spatial à afficher. D’autres données spatiales peuvent y être superposées avec <code>+</code>.</p>
<p>Il existe des arguments facultatifs pour contrôler l’affichage de chaque type d’objet. Dans l’exemple ci-dessous, nous utilisons l’argument <code>zcol</code> pour choisir la variable qui sera assignée à la couleur des points de <code>plots_01_11</code>.</p>
<pre class="r"><code>library(mapview)

mapview(cdem) +
    mapview(plots_01_11, zcol = &quot;cover_type&quot;)</code></pre>
<div class="figure">
<img src="images/mapview_example.png" alt="Exemple mapview" />
<p class="caption">Exemple mapview</p>
</div>
<hr />
</div>
<div id="ref" class="section level2">
<h2>Références supplémentaires (en anglais)</h2>
<ul>
<li><p>Le manuel en-ligne <a href="https://keen-swartz-3146c4.netlify.com/">Spatial Data Science</a> d’Edzer Pebesma et Roger Bivand présente les packages <strong><em>sf</em></strong> et <strong><em>stars</em></strong> en plus de détails, en plus d’inclure des chapitres sur l’analyse statistique de donnnées spatiales.</p></li>
<li><p><a href="https://geocompr.robinlovelace.net/">Geocomputation with R</a> (Lovelace, Nowosad et Muenchow) est un autre manuel complet et gratuit sur le traitement et l’analyse de données spatiales.</p></li>
<li><p>Le blogue <a href="https://www.r-spatial.org">R-spatial</a> présente des nouvelles et des tutoriels sur le traitement des données spatiales dans R. En particulier, cette série (<a href="https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html">1</a>, <a href="https://www.r-spatial.org/r/2018/10/25/ggplot2-sf-2.html">2</a>, <a href="https://www.r-spatial.org/r/2018/10/25/ggplot2-sf-3.html">3</a>) de billets par Mel Moreno et Mathieu Basille montre comment produire des cartes élaborées avec <em>ggplot2</em>.</p></li>
<li><p>Le site web <a href="https://rspatial.org/">RSpatial</a> (à ne pas confondre avec le précédent) inclut des tutoriels pour les packages <em>raster</em> et <em>terra</em> pour travailler avec des données matricielles.</p></li>
</ul>
<hr />
</div>
<div id="data" class="section level2">
<h2>Sources des données</h2>
<p>Toutes les données de cet atelier proviennent de sources publiques des gouvernements du Québec et du Canada. Le script <code>data_prep.R</code> montre les étapes pour produire les fichiers de l’atelier à partir des données originales.</p>
<ul>
<li><p>Les <a href="https://mern.gouv.qc.ca/territoire/portrait/portrait-donnees-mille.jsp">limites</a> des municipalités régionales de comté (MRC) proviennent du Ministère de l’Énergie et des Ressources Naturelles du Québec (MERN) et les <a href="https://www.stat.gouv.qc.ca/statistiques/population-demographie/structure/mrc-total.xlsx">données de population</a> proviennent de l’Institut de la statistique du Québec. Les noms des colonnes ont été traduits en anglais et les accents ont été retirés.</p></li>
<li><p>Les données des <a href="https://www.donneesquebec.ca/recherche/fr/dataset/placettes-echantillons-permanentes-1970-a-aujourd-hui">placettes d’inventaire forestier</a> et les <a href="https://www.donneesquebec.ca/recherche/fr/dataset/donnees-sur-les-perturbations-naturelles-insecte-tordeuse-des-bourgeons-de-lepinette">cartes de défoliation par la tordeuse des bourgeons de l’épinette</a> ont été téléchargées de Données Québec et proviennent du Ministère des Forêts, de la Faune et des Parcs (MFFP). Certains champs de donnés ont été recodés et traduits en anglais.</p></li>
<li><p>Le <a href="https://open.canada.ca/data/en/dataset/7f245e4d-76c2-4caa-951a-45d1d2051333">modèle numérique d’élévation du Canada</a> provient de Ressources naturelles Canada et a été téléchargé sur le portail de données ouvertes du gouvernement du Canada. Deux sections de 2x1 degrés ont été fusionnées pour cet atelier.</p></li>
</ul>
<hr />
</div>
<div id="sol" class="section level2">
<h2>Solutions des exercices</h2>
<div id="sol1" class="section level3">
<h3>Exercice 1</h3>
<p>Choisissez les MRC de la région du Bas-St-Laurent (<em>reg_id</em>: 01) et de la Gaspésie (<em>reg_id</em>: 11), puis affichez leur population de 2016 sur une carte.</p>
<pre class="r"><code>mrc_01_11 &lt;- mrc[mrc$reg_id %in% c(&quot;01&quot;, &quot;11&quot;), ]
plot(mrc_01_11[&quot;pop2016&quot;], axes = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol1-1.png" width="672" /></p>
<p><a href="#retour1">Retour</a></p>
</div>
<div id="sol2" class="section level3">
<h3>Exercice 2</h3>
<p>Créez une carte des MRC avec des couleurs de remplissage différentes pour chaque région.</p>
<pre class="r"><code>ggplot(data = mrc_proj, aes(fill = reg_name)) +
    geom_sf()</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol2-1.png" width="672" /></p>
<p><a href="#retour2">Retour</a></p>
</div>
<div id="sol3" class="section level3">
<h3>Exercice 3</h3>
<ol style="list-style-type: lower-alpha">
<li>Combien de placettes dans ces régions sont affectées à chaque niveau de défoliation?</li>
</ol>
<pre class="r"><code>defo &lt;- st_read(&quot;data/tbe2016_gaspe.shp&quot;)</code></pre>
<pre><code>## Reading layer `tbe2016_gaspe&#39; from data source `Z:\cours\atelier_rgeo\data\tbe2016_gaspe.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 3928 features and 2 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -69.88925 ymin: 47.38829 xmax: -64.66188 ymax: 49.25522
## CRS:            4269</code></pre>
<pre class="r"><code>plots_defo &lt;- st_join(plots_01_11, defo)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar
## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>table(plots_defo$level)</code></pre>
<pre><code>## 
##  1  2  3 
## 93 93 90</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>Produisez une carte des régions défoliées situées dans la MRC de Kamouraska, avec les limites de la MRC.</li>
</ol>
<pre class="r"><code>mrc_kam &lt;- filter(mrc_01_11, mrc_name == &quot;Kamouraska&quot;)
defo_kam &lt;- st_join(defo, mrc_kam, left = FALSE)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>ggplot() +
    geom_sf(data = mrc_kam) +
    geom_sf(data = defo_kam, color = NA, aes(fill = level))</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol3b-1.png" width="672" /></p>
<p><a href="#retour3">Retour</a></p>
</div>
<div id="sol4" class="section level3">
<h3>Exercice 4</h3>
<ol style="list-style-type: lower-alpha">
<li>Affichez une carte montrant à quels endroits l’élévation est entre 5 et 100 m dans la MRC de La Mitis.</li>
</ol>
<pre class="r"><code>mitis &lt;- filter(mrc_01_11, mrc_name == &quot;La Mitis&quot;)
mitis &lt;- st_transform(mitis, st_crs(cdem))

cdem_mitis &lt;- st_crop(cdem, mitis)</code></pre>
<pre><code>## although coordinates are longitude/latitude, st_intersects assumes that they are planar</code></pre>
<pre class="r"><code>plot(cdem_mitis &gt;= 5 &amp; cdem_mitis &lt;= 100)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol4a-1.png" width="672" /></p>
<ol start="2" style="list-style-type: lower-alpha">
<li>Quel est la plus grande valeur d’élévation dans cette MRC?</li>
</ol>
<pre class="r"><code>cdem_mitis_vals &lt;- cdem_mitis[[1]]
max(cdem_mitis_vals, na.rm = TRUE)</code></pre>
<pre><code>## [1] 794.4375</code></pre>
<p><a href="#retour4">Retour</a></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
