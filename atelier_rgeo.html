<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Philippe Marchand, Université du Québec en Abitibi-Témiscamingue" />


<title>Introduction à l’analyse de données géospatiales avec R</title>

<script src="atelier_rgeo_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="atelier_rgeo_files/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="atelier_rgeo_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="atelier_rgeo_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="atelier_rgeo_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="atelier_rgeo_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="atelier_rgeo_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="atelier_rgeo_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="atelier_rgeo_files/navigation-1.1/tabsets.js"></script>
<link href="atelier_rgeo_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="atelier_rgeo_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Introduction à l’analyse de données géospatiales avec R</h1>
<h4 class="author"><em>Philippe Marchand, Université du Québec en Abitibi-Témiscamingue</em></h4>
<h4 class="date"><em>11 mai 2018</em></h4>

</div>


<hr />
<p>Cet atelier se veut un survol des outils disponibles en R pour l’analyse de données géoréférencées. Ce type de données apparaît de plus en plus fréquemment dans divers domaines (ex.: photos aériennes, images satellite, données du recensement, lieux rattachés aux messages sur les réseaux sociaux, etc.). Il existe deux grandes catégories de données géoréférencées: les données matricielles représentent des variables définies à chaque point d’une grille couvrant tout l’espace représenté (comme une image satellite), tandis que les données vectorielles associent des variables à des objets géométriques placés à des endroits précis (comme la position des villes et des chemins sur une carte routière).</p>
<p>Au départ, l’utilisation de commandes de programmation pour manipuler des données géographiques peut sembler moins intuitif que l’interface graphique de logiciels spécialisés (ex.: ArcGIS). Voici quelques avantages d’une analyse programmée:</p>
<ul>
<li>Il est facile de répéter l’analyse pour de nouvelles données en ré-exécutant le programme.</li>
<li>Il est facile pour d’autres chercheurs de reproduire la méthodologie s’ils ont accès au même langage de programmation.</li>
<li>Dans le cas spécifique de R, on peut extraire des variables spatiales et les combiner à d’autres analyses statistiques avec un seul programme.</li>
</ul>
<div id="objectifs" class="section level2">
<h2>Objectifs</h2>
<ul>
<li>Se familiariser avec les principaux packages permettant le traitement et la visualisation simple de données vectorielles (<strong><em>sf</em></strong>) et matricielles (<strong><em>raster</em></strong>) en R.</li>
<li>Effectuer des transformations de données courantes à l’aide des fonctions de ces packages.</li>
<li>Connaître certains packages permettant des visualisations plus complexes: <strong><em>tmap</em></strong> pour des cartes statiques et <strong><em>mapview</em></strong> pour des cartes interactives.</li>
</ul>
</div>
<div id="table-des-matieres" class="section level2">
<h2>Table des matières</h2>
<ul>
<li><a href="#vect">Explorer un jeu de données vectoriels</a></li>
<li><a href="#crs">Systèmes de coordonnées et transformations</a></li>
<li><a href="#vectop">Opérations géométriques sur les données vectorielles</a></li>
<li><a href="#tmap">Cartes thématiques avec <em>tmap</em></a></li>
<li><a href="#mat">Traitement des données matricielles</a></li>
<li><a href="#ext">Extraire des données matricielles à partir d’objets géométriques</a></li>
<li><a href="#mapview">Cartes interactives avec <em>mapview</em></a></li>
<li><a href="#ref">Références</a></li>
<li><a href="#sol">Solutions des exercices</a></li>
</ul>
<hr />
</div>
<div id="vect" class="section level2">
<h2>Explorer un jeu de données vectoriel</h2>
<p>Le répertoire <em>mrc</em> contient les coordonnées des municipalités régionales de comté (MRC) du Québec en format <em>ESRI shapefile</em> (<a href="https://www.mern.gouv.qc.ca/territoire/portrait/portrait-donnees-mille.jsp">source originale des données</a>). Notez que l’information pour chaque jeu de données est contenue dans plusieurs fichiers, qui portent le même nom mais diffèrent par leur extension.</p>
<p>Pour charger un jeu de données dans R, nous appelons la fonction <code>st_read</code> (toutes les fonctions du package <strong><em>sf</em></strong> ont le préfixe <code>st_</code>, pour spatiotemporel) avec le nom du fichier <em>.shp</em>.</p>
<pre class="r"><code>library(sf)
## Linking to GEOS 3.6.1, GDAL 2.2.3, proj.4 4.9.3

mrc &lt;- st_read(&quot;mrc/mrc_polygone.shp&quot;, stringsAsFactors = FALSE)
## Reading layer `mrc_polygone&#39; from data source `C:\Users\marchanp\Desktop\atelier_rgeo\mrc\mrc_polygone.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 137 features and 12 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -79.7625 ymin: 44.99136 xmax: -56.93495 ymax: 62.58217
## epsg (SRID):    4269
## proj4string:    +proj=longlat +datum=NAD83 +no_defs</code></pre>
<p>Le texte de sortie indique certaines propriétés du jeu de données chargé, incluant le type de géométrie (POLYGON), les limites spatiales du jeu de données (<em>bbox</em>) et le système de coordonnées utilisé. Ce dernier est décrit sous deux formats: un code numérique <em>epsg</em> et une chaîne de caractère <em>proj4string</em>. Nous traiterons davantage des systèmes de coordonnées plus loin.</p>
<p>Ces propriétés peuvent être extraites séparément à l’aide des fonctions <code>st_bbox</code> et <code>st_crs</code>:</p>
<pre class="r"><code>st_bbox(mrc)
##      xmin      ymin      xmax      ymax 
## -79.76250  44.99136 -56.93495  62.58217
st_crs(mrc)
## Coordinate Reference System:
##   EPSG: 4269 
##   proj4string: &quot;+proj=longlat +datum=NAD83 +no_defs&quot;</code></pre>
<p>Regardons un aperçu du jeu de données:</p>
<pre class="r"><code>class(mrc)
## [1] &quot;sf&quot;         &quot;data.frame&quot;
head(mrc)
## Simple feature collection with 6 features and 12 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -79.7625 ymin: 48.92349 xmax: -63.31941 ymax: 62.58217
## epsg (SRID):    4269
## proj4string:    +proj=longlat +datum=NAD83 +no_defs
##           AREA  PERIMETER MRC_S_ MRC_S_ID     MRS_NO_IND
## 1 7.828380e+01 77.0855365      2        1 50 02 0040 000
## 2 4.743960e-02  1.6709096      3        2 50 02 0040 000
## 3 4.502033e+01 55.2806743      4        3 50 02 0040 000
## 4 7.530857e-04  0.1519356      5        4 50 02 0010 000
## 5 1.024437e+01 23.4016618      6        5 50 02 0010 000
## 6 5.028808e-01  8.8274338      7        6 50 02 0010 000
##                                     MRS_DE_IND MRS_CO_MRC
## 1 Municipalité régionale de comté géographique        992
## 2 Municipalité régionale de comté géographique        993
## 3 Municipalité régionale de comté géographique        991
## 4   MRC (incluant les territoires autochtones)        972
## 5   MRC (incluant les territoires autochtones)        972
## 6   MRC (incluant les territoires autochtones)        972
##                         MRS_NM_MRC MRS_CO_REG     MRS_NM_REG MRS_CO_REF
## 1 Administration régionale Kativik         10 Nord-du-Québec     BDGA1M
## 2         Nouveau toponyme à venir         10 Nord-du-Québec     BDGA1M
## 3                          Jamésie         10 Nord-du-Québec     BDGA1M
## 4                      Caniapiscau         09      Côte-Nord     BDGA1M
## 5                      Caniapiscau         09      Côte-Nord     BDGA1M
## 6                      Caniapiscau         09      Côte-Nord     BDGA1M
##   MRS_CO_VER                       geometry
## 1   V2017-08 POLYGON ((-77.82293 55.2603...
## 2   V2017-08 POLYGON ((-77.82293 55.2603...
## 3   V2017-08 POLYGON ((-78.49988 55.0008...
## 4   V2017-08 POLYGON ((-66.6878 55.00005...
## 5   V2017-08 POLYGON ((-70.02987 55.0000...
## 6   V2017-08 POLYGON ((-66.25978 55.0000...</code></pre>
<p>Un objet de classe <code>sf</code> est en fait un <code>data.frame</code> spécialisé, où chaque ligne contient des champs de données qui sont associés à un objet géométrique, décrit dans la colonne <code>geometry</code>. Les types géométriques les plus courants sont:</p>
<ul>
<li>POINT: Coordonnées (<em>x</em>, <em>y</em>) d’un point.</li>
<li>LINESTRING: Séquence de points reliés par des segments de droite.</li>
<li>POLYGON: Séquence de points formant un polygone simple fermé.</li>
<li>MULTIPOINT, MULTILINESTRING ou MULTIPOLYGON: Jeu de données où chaque objet peut être composé de plusieurs points ou lignes ou polygones.</li>
</ul>
<p>La fonction <code>plot</code> appliquée à un objet <code>sf</code> crée une carte de chaque attribut du jeu de données.</p>
<pre class="r"><code>plot(mrc)
## Warning: plotting the first 10 out of 12 attributes; use max.plot = 12 to
## plot all</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_sf-1.png" /><!-- --></p>
<p>Pour n’afficher qu’un attribut, il faut sélectionner la colonne correspondante. Pour n’afficher que la carte sans données, on peut choisir la colonne <code>geometry</code>. Le paramètre <code>axes = TRUE</code> indique au programme d’afficher les axes de coordonnées.</p>
<pre class="r"><code>plot(mrc[, &quot;geometry&quot;], axes = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_geom-1.png" /><!-- --></p>
<div id="retour1" class="section level3">
<h3>Exercice 1</h3>
<p>Produisez une carte coloriée par région administrative, ex.: Nord-du-Québec, Côte-Nord, etc.</p>
<p><a href="#sol1">Solution</a></p>
<hr />
<p>La fonction <code>st_as_sf</code> permet de convertir un <code>data.frame</code> contenant des coordonnées géographiques en objet <code>sf</code>. Il suffit de spécifier les colonnes contenant les coordonnées ainsi que le système de coordonnées utilisé.</p>
<p>Ici, créons un jeu de données d’un seul point correspondant à la position de l’UQAT, avec le même système de coordonnées que <code>mrc</code> (longitude et latitude).</p>
<pre class="r"><code>uqat &lt;- data.frame(nom = &quot;UQAT&quot;, long = -79.0086, lat = 48.2306)
uqat &lt;- st_as_sf(uqat, coords = c(&quot;long&quot;, &quot;lat&quot;), crs = st_crs(mrc))</code></pre>
<p>Le package <strong><em>sf</em></strong> inclut différentes fonctions de comparaison entre données géométriques. Pour déterminer quel polygone de <code>mrc</code> contient le point <code>uqat</code>, on utilise la fonction <code>st_within</code>:</p>
<pre class="r"><code>st_within(uqat, mrc)
## although coordinates are longitude/latitude, st_within assumes that they are planar
## Sparse geometry binary predicate list of length 1, where the predicate was `within&#39;
##  1: 56</code></pre>
<p>L’avertissement nous rappelle que les opérations géométriques de ce package sont basées sur un plan <em>xy</em> plutôt que des coordonnées sphériques (plus de détails ci-dessous).</p>
<p>Le résultat d’une comparaison entre deux jeux de données géométriques est une liste qui, pour chaque objet du premier jeu de données, contient les indices des objets du deuxième jeu de données auxquels la relation s’applique. Donc ici, le point 1 (et seul point) dans <code>uqat</code> est contenu (<em>within</em>) dans le polygone 56 de <code>mrc</code>. On peut vérifier de quelle MRC il s’agit:</p>
<pre class="r"><code>mrc[56, ]
## Simple feature collection with 1 feature and 12 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -79.51763 ymin: 47.70263 xmax: -78.22 ymax: 48.57511
## epsg (SRID):    4269
## proj4string:    +proj=longlat +datum=NAD83 +no_defs
##         AREA PERIMETER MRC_S_ MRC_S_ID     MRS_NO_IND
## 56 0.7832265  4.624354     57       58 50 02 0040 000
##                                      MRS_DE_IND MRS_CO_MRC    MRS_NM_MRC
## 56 Municipalité régionale de comté géographique         86 Rouyn-Noranda
##    MRS_CO_REG            MRS_NM_REG MRS_CO_REF MRS_CO_VER
## 56         08 Abitibi-Témiscamingue     BDGA1M   V2017-08
##                          geometry
## 56 POLYGON ((-79.51749 48.4306...</code></pre>
<p>Pour afficher différents jeux de données sur la même carte, on appelle d’abord <code>plot</code> avec le paramètre <code>reset = FALSE</code>, puis on ajoute un autre jeu de données avec le paramètre <code>add = TRUE</code>.</p>
<pre class="r"><code>plot(mrc[, &quot;geometry&quot;], reset = FALSE, axes = TRUE)
plot(uqat, add = TRUE, pch = 20, col = &quot;red&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_overlap-1.png" /><!-- --></p>
<p><strong>Rappel</strong></p>
<ul>
<li>Les données spatiales vectorielles associent des champs de donnés à des objets géométriques tels que des points, lignes et polygones. Le package <strong><em>sf</em></strong> permet de travailler avec ces données dans R.</li>
<li>Pour lire un jeu de données vectoriel: <code>st_read</code>.</li>
<li>Pour convertir un jeu de données standard (<code>data.frame</code>) en objet spatial: <code>st_as_sf</code>.</li>
<li>Toutes les opérations de base des objets <code>data.frame</code> s’appliquent aussi aux objets <em>sf</em>.</li>
<li>La fonction <code>plot</code> appliquée à un objet <code>sf</code> permet d’afficher un ou plusieurs champs de données sur une carte.</li>
<li>Relation d’inclusion entre objets géométriques: <code>st_within</code>.</li>
</ul>
<hr />
</div>
</div>
<div id="crs" class="section level2">
<h2>Systèmes de coordonnées et transformations</h2>
<p>Jusqu’à présent, nous avons travaillé avec des données utilisant un système de coordonnées géographiques, où les positions sont exprimées en degrés de longitude et latitude. Ces coordonnées sont basées sur un modèle qui approxime la surface irrégulière du niveau moyen de la mer autour de la Terre (appelée géoïde) par une ellipsoïde (une sphère légèrement aplatie). Il existe plusieurs de ces modèles, appelés systèmes de référence géodésique ou <em>datum</em> en anglais: les coordonnées de <code>mrc</code> sont définies avec le système NAD83, tandis que plusieurs cartes à l’échelle mondiale sont basées sur le système WGS84.</p>
<p>Tel que mentionné ci-dessus, les fonctions du packages <strong><em>sf</em></strong> sont basées sur la géométrie plane. Ces fonctions, comme le calcul de l’intersection entre deux lignes ou polygones, le calcul de distances entre points, etc. ignorent la courbure de la Terre et produiront des résultats erronés si elles sont appliquées à des coordonnées sphériques. Notez que le package <strong><em>geosphere</em></strong> permet de calculer des distances et courbes géodésiques en tenant compte du modèle d’ellipsoïde.</p>
<p>Une projection convertit les coordonnées géographiques en coordonnées planes. Puisqu’il est impossible de représenter fidèlement la surface entière du globe sur un plan, des projections spécialisées ont été développées en fonction de la région du monde et des besoins précis.</p>
<p>Par exemple, les images ci-dessous montrent comment des aires circulaires identiques à différents points du globe apparaissent sur une projection de Mercator (formes comparables) et sur une projection équivalente de Lambert (aires comparables). <img src="images/Mercator_distortion.png" alt="Projection de Mercator" /> <img src="images/Lambert_distortion.png" alt="Projection équivalente de Lambert" /></p>
<p>Nous allons convertir les polygones <code>mrc</code> et le point <code>uqat</code> dans une projection conique conforme de Lambert centrée sur le Québec (<a href="https://epsg.io/6622">code EPSG: 6622</a>), en utilisant la fonction <code>st_transform</code>.</p>
<pre class="r"><code>mrc_proj &lt;- st_transform(mrc, 6622)
uqat_proj &lt;- st_transform(uqat, 6622)

uqat_proj
## Simple feature collection with 1 feature and 1 field
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: -774896.9 ymin: 527230.8 xmax: -774896.9 ymax: 527230.8
## epsg (SRID):    6622
## proj4string:    +proj=lcc +lat_1=60 +lat_2=46 +lat_0=44 +lon_0=-68.5 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
##    nom                   geometry
## 1 UQAT POINT (-774896.9 527230.8)</code></pre>
<p>Il est important de toujours utiliser la fonction <code>st_transform</code> pour convertir des jeux de données entre différents système de coordonnées. Une erreur courante consiste à changer la définition du système de coordonnées (par exemple, avec la fonction<code>st_crs</code>) sans transformer les données elles-mêmes.</p>
<p>Notez que les coordonnées projetées sont exprimées en mètres (“+units=m” dans la <em>proj4string</em>). Ces coordonnées sont relatives à un point d’origine défini par la projection.</p>
<pre class="r"><code>plot(mrc_proj[, &quot;geometry&quot;], axes = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_geom_proj-1.png" /><!-- --></p>
<p>On peut créer une carte montrant les lignes de latitude et longitude superposées aux données projetées, avec le paramètre <code>graticule</code> auquel on associe le système de coordonnées géographique des données originales:</p>
<pre class="r"><code>plot(mrc_proj[, &quot;geometry&quot;], axes = TRUE, reset = FALSE, 
     graticule = st_crs(mrc))
plot(uqat_proj, add = TRUE, pch = 20, col = &quot;red&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_graticule-1.png" /><!-- --></p>
<p><strong>Rappel</strong></p>
<ul>
<li>Un système de coordonnées géographique est basé sur un modèle géodésique (<em>datum</em>) et donne la position en coordonnées sphériques (longitude, latitude) mesurées en degrés.</li>
<li>Un système de coordonnées projeté convertit les coordonnées sphériques en coordonnées planes (<em>x</em>, <em>y</em>) mesurées en mètres.</li>
<li><code>st_crs</code> indique le système de coordonnées d’un objet <em>sf</em>; <code>st_transform</code> convertit les coordonnées d’un système à un autre.</li>
</ul>
<hr />
</div>
<div id="vectop" class="section level2">
<h2>Opérations géométriques sur les données vectorielles</h2>
<p>Maintenant que nos données sont projetées, utilisons la fonction <code>st_buffer</code> pour définir un rayon de 100km autour du point <code>uqat</code>, que nous ajouterons à la carte:</p>
<pre class="r"><code>rayon &lt;- st_buffer(uqat_proj, dist = 100000)

plot(mrc_proj[, &quot;geometry&quot;], axes = TRUE, reset = FALSE, 
     graticule = st_crs(mrc))
plot(uqat_proj, add = TRUE, pch = 20, col = &quot;red&quot;)
plot(rayon[, &quot;geometry&quot;], add = TRUE, border = &quot;blue&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/buffer-1.png" /><!-- --></p>
<p><strong>Question</strong>: Combien y a-t-il de côtés dans le polygone <code>rayon</code>? (Regardez la colonne <code>geometry</code>.) C’est la valeur par défaut, mais un paramètre optionel de <code>st_buffer</code> permet de varier la résolution des segments circulaires.</p>
<div id="retour2" class="section level3">
<h3>Exercice 2</h3>
<p>La fonction <code>st_intersection(A, B)</code> retourne l’intersection de deux jeux de données vectoriels <code>A</code> et <code>B</code>, c’est-à-dire les régions où leurs objets géométriques se superposent. Avec cette fonction, identifiez le nombre de MRC situées dans un rayon de 100km du point <code>uqat</code>, puis essayez de les indiquer sur une carte représentant ce rayon.</p>
<p><a href="#sol2">Solution</a></p>
<hr />
<p>Pour chaque polygone de l’intersection entre les deux jeux de données, la fonction <code>st_intersection</code> copie les champs de données corresponant aux deux polygones originaux. L’avertissement (<em>“attribute variables are assumed to be spatially constant”</em>) nous rappelle que ces champs de données ne s’appliquent pas nécessairement aux sous-régions produites.</p>
<p>Par exemple, le champ <em>AREA</em> de <code>mrc</code> réfère à l’aire de la MRC complète – en plus, celle-ci est exprimée en degrés carrés, ce qui n’est pas très utile. Pour des données projetées, la fonction <code>st_area</code> permet de calculer l’aire des polygones en mètres carrés.</p>
<p>Parmi les autres opérations géométriques utiles, notons <code>st_union</code>, qui combine plusieurs objets géométriques en un seul, ainsi que <code>st_difference</code>, qui enlève d’un jeu de données la région recouverte par un autre jeu de données.</p>
<pre class="r"><code>poly_union &lt;- st_union(mrc_proj)
plot(poly_union)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/union-1.png" /><!-- --></p>
<pre class="r"><code>poly_diff &lt;- st_difference(mrc_proj, rayon)
## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries
plot(poly_diff[, &quot;geometry&quot;])</code></pre>
<p><img src="atelier_rgeo_files/figure-html/difference-1.png" /><!-- --></p>
<p><strong>Rappel</strong></p>
<ul>
<li>Toutes les opérations géométriques du package <strong><em>sf</em></strong> sont basées sur la géométrie plane. Elles traitent la longitude et latitude comme des axes perpendiculaires (<em>x</em>, <em>y</em>).</li>
<li><code>st_buffer</code> crée une zone tampon à une distance donnée autour d’un objet géométrique.</li>
<li><code>st_distance</code> calcule la distance entre deux objets; <code>st_area</code> calcule l’aire d’un objet.</li>
<li><code>st_union</code> combine tous les objets géométriques d’un jeu de données vectoriel.</li>
<li><code>st_intersection(A, B)</code> produit un jeu de données contenant toutes les régions ou les objets géométriques de <em>A</em> et <em>B</em> se superposent.</li>
<li><code>st_difference(A, B)</code> retire de <em>A</em> les régions aussi recouvertes par <em>B</em>.</li>
</ul>
<hr />
</div>
<div id="retour3" class="section level3">
<h3>Exercice 3</h3>
</div>
<div id="defoliation-due-a-la-livree-des-forets-sur-le-territoire-de-rouyn-noranda" class="section level3">
<h3>Défoliation due à la livrée des forêts sur le territoire de Rouyn-Noranda</h3>
<p>Les dossier <em>livree</em> contient des données sur la défoliation due à la livrée des forêts (<em>Malacosoma disstria</em>) au Québec entre 2014 et 2017 (<a href="https://www.donneesquebec.ca/recherche/fr/dataset/donnees-sur-les-perturbations-naturelles-insecte-livree-des-forets">source des données sur Données Québec</a>).</p>
<pre class="r"><code>livree &lt;- st_read(&quot;livree/Livree_2014_2017.shp&quot;)
## Reading layer `Livree_2014_2017&#39; from data source `C:\Users\marchanp\Desktop\atelier_rgeo\livree\Livree_2014_2017.shp&#39; using driver `ESRI Shapefile&#39;
## Simple feature collection with 2944 features and 4 fields
## geometry type:  MULTIPOLYGON
## dimension:      XY
## bbox:           xmin: -79.57113 ymin: 45.00835 xmax: -71.60867 ymax: 48.74596
## epsg (SRID):    4269
## proj4string:    +proj=longlat +datum=NAD83 +no_defs</code></pre>
<p>Pour chaque polygone de défoliation, le jeu de données indique l’année, la superficie en hectares (<em>SupHaCea</em>), ainsi que l’intensité de défoliation sous forme de texte (<em>Niveau</em>) et d’indice numérique (<em>Ia</em>): Léger (1), Modéré (2) ou Grave (3).</p>
<p>Nous allons d’abord extraire les données de 2017 seulement. Puisqu’un jeu de données spatial est aussi un <code>data.frame</code>, on peut utiliser les méthodes habituelles en R pour filtrer les données selon un des champs.</p>
<pre class="r"><code>livree2017 &lt;- livree[livree$ANNEE == 2017, ]</code></pre>
<p>Pour cet exercice, vous devrez:</p>
<ul>
<li>Déterminer la superficie totale (en hectares) défoliée par la livrée des forêts sur le territoire de la MRC de Rouyn-Noranda.</li>
<li>Produire une carte des surfaces défoliées avec leur niveau d’intensité pour ce territoire.</li>
</ul>
<p>Étapes suggérées:</p>
<ul>
<li>Extraire la MRC de Rouyn-Noranda du jeu de données <code>mrc</code>.</li>
<li>Extraire les données de <code>livree2017</code> situées dans les limites de la MRC. Avant d’appliquer des opérateurs de comparaison spatiale, assurez-vous que les jeux de données soient comparables. Il est correct de travailler en coordonnées géographiques (longitude et latitude) cette fois-ci.</li>
</ul>
<p><a href="#sol3">Solution</a></p>
<p><strong>Question:</strong> Quels sont les problèmes potentiels avec cette méthode (voir les avertissements de R)?</p>
<ul>
<li>Si les polygones de défoliation étaient très près des limites de la MRC, l’intersection des polygones en coordonnées géographiques ne serait pas exacte.</li>
<li>Si des polygones chevauchaient les limites de la MRC, la superficie indiquée <em>SupHaCea</em> inclurait la partie extérieure.</li>
</ul>
<p>Ici, aucun des polygones n’est situé sur la limite, donc notre méthode est valide. Par contre, si on fait l’intersection avec l’ensemble des MRC, plusieurs polygones se retrouvent comptés deux fois:</p>
<pre class="r"><code>livree_mrc &lt;- st_intersection(livree2017, mrc)
## although coordinates are longitude/latitude, st_intersection assumes that they are planar
## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries
sum(livree2017$SupHaCea) # Somme des superficies originales
## [1] 305654.6
sum(livree_mrc$SupHaCea) # Somme des superficies après l&#39;intersection
## [1] 383485.2</code></pre>
<p>En revenant aux données pour Rouyn-Noranda, on peut utiliser la fonction <code>aggregate</code> pour calculer le nombre d’hectares défoliés par niveau d’intensité:</p>
<pre class="r"><code>aggregate(SupHaCea ~ Niveau, data = livree_rn, sum)
##   Niveau SupHaCea
## 1  Grave 18377.87
## 2  Léger 16187.58
## 3 Modéré 18228.49</code></pre>
</div>
<div id="compatibilite-avec-dautres-packages" class="section level3">
<h3>Compatibilité avec d’autres packages</h3>
<p>Pour ceux qui connaissent le package de manipulation des données <strong><em>dplyr</em></strong>, notez qu’il est compatible avec les jeux de données spatiaux chargés par <em>sf</em>. Ainsi, l’exemple précédent (avec <code>aggregate</code>) aurait pu être reproduit avec les fonctions <code>group_by</code> et <code>summarize</code> de <em>dplyr</em>.</p>
<p>La prochaine version du package de graphiques <strong><em>ggplot2</em></strong> inclura aussi des fonctions pour faciliter la production de cartes thématiques à partir d’objets <code>sf</code>.</p>
<p>Voir <a href="http://strimas.com/r/tidy-sf/">cette page</a> pour plus d’exemples de l’intégration entre <em>sf</em> et ces packages.</p>
<hr />
</div>
</div>
<div id="tmap" class="section level2">
<h2>Cartes thématiques avec tmap</h2>
<p>Jusqu’à maintenant, nous avons visualisé les données spatiales avec la fonction <code>plot</code>. Pour produire des cartes plus détaillées, par exemple pour une publication, le package <strong><em>tmap</em></strong> peut être utile. Pour créer une carte avec <em>tmap</em>, on définit d’abord les objets géométriques à présenter avec <code>tm_shape</code>, puis on ajoute des couches représentant diverses données. Par exemple, la fonction <code>tm_fill</code> associe une variable à la couleur intérieure des polygones:</p>
<pre class="r"><code>library(tmap)

tm_shape(livree_mrc) +
    tm_fill(&quot;Niveau&quot;) </code></pre>
<p><img src="atelier_rgeo_files/figure-html/tmap-1.png" /><!-- --></p>
<p>L’ajout d’éléments au graphique avec le symbole <code>+</code> est inspirée du package graphique <em>ggplot2</em>. Comme ce dernier, <em>tmap</em> peut diviser les données en facettes selon une des variables du jeu de données. Ici, nous utiliserons la région adminsitrative indiquée dans la colonne <em>MRS_NM_REG</em>:</p>
<pre class="r"><code>tm_shape(livree_mrc) +
    tm_fill(&quot;Niveau&quot;) +
    tm_facets(&quot;MRS_NM_REG&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/tmap_facets-1.png" /><!-- --></p>
<p>Finalement, voici comment superposer à ces données les limites des MRC (avec <code>tm_polygons</code>) et leur nom (avec <code>tm_text</code>). Notez que l’ordre dans lequel les éléments sont définis détermine leur superposition sur la carte:</p>
<pre class="r"><code>tm_shape(mrc) +
    tm_polygons() +
    tm_text(&quot;MRS_NM_MRC&quot;) +
tm_shape(livree_mrc) +
    tm_fill(&quot;Niveau&quot;) +
    tm_facets(&quot;MRS_NM_REG&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/tmap_overlap-1.png" /><!-- --></p>
<p><strong>Rappel</strong></p>
<ul>
<li>Le package <strong><em>tmap</em></strong> permet de produire des cartes combinant différents champs de données d’un ou plusieurs jeux de données vectoriels.</li>
<li>La première instruction d’une carte doit être <code>tm_shape</code>, indiquant les jeu de données à utiliser.</li>
<li>On peut ensuite ajouter des couches associant certains champs de données à des propriétés du graphique, ex.: <code>tm_fill</code>, <code>tm_text</code>.</li>
<li><code>tm_facets</code> permet de diviser la carte en plusieurs images selon la valeur d’un champ de données.</li>
</ul>
<hr />
</div>
<div id="mat" class="section level2">
<h2>Exemple de données matricielles: le modèle numérique d’élévation du Canada</h2>
<p>Le dossier <em>cdem</em> contient des données régionales tirées du <a href="https://ouvert.canada.ca/data/fr/dataset/7f245e4d-76c2-4caa-951a-45d1d2051333">modèle numérique d’élévation du Canada</a>, ou CDEM selon son acronyme anglais, produit par Ressources naturelles Canada.</p>
<p>Le CDEM est un jeu de données matriciel; une grille régulière est superposée à la surface du Canada et le modèle associe une valeur d’élévation (en mètres) à chaque pixel sur cette grille. Ce type de données est analogue à une image numérique, à laquelle on ajoute des méta-données (résolution, étendue et système de coordonnées) qui permettent de rattacher à chaque pixel des coordonnées géographiques.</p>
<p>La résolution de base du CDEM est 1/4800 de degré et les données sont disponibles en sections de 2 degrés de longitude par 1 degré de latitude. Nous allons d’abord charger l’index du CDEM, un fichier indiquant la région rectangulaire correspondant à chaque section. Cet index se trouve aussi dans le dossier <em>cdem</em> sous format <em>.kml</em>, un type de données vectorielles utilisé notamment par Google Earth.</p>
<pre class="r"><code>cdem_index &lt;- st_read(&quot;cdem/cdem_index_250k.kml&quot;, stringsAsFactors = FALSE)
## Reading layer `cdem_shp_index&#39; from data source `C:\Users\marchanp\Desktop\atelier_rgeo\cdem\cdem_index_250k.kml&#39; using driver `KML&#39;
## Simple feature collection with 969 features and 2 fields
## geometry type:  GEOMETRYCOLLECTION
## dimension:      XYZ
## bbox:           xmin: -142 ymin: 41 xmax: -52 ymax: 83
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs</code></pre>
<p><strong>Question:</strong> Quel opération utiliseriez-vous pour déterminer les sections du CDEM couvrant l’étendue de la MRC de Rouyn-Noranda?</p>
<pre class="r"><code>rn &lt;- mrc[mrc$MRS_NM_MRC == &quot;Rouyn-Noranda&quot;, ]
cdem_index &lt;- st_transform(cdem_index, st_crs(rn))
cdem_rn &lt;- st_intersection(cdem_index, rn)
## although coordinates are longitude/latitude, st_intersection assumes that they are planar
## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries
cdem_rn$Name
## [1] &quot;031M&quot; &quot;032D&quot;</code></pre>
<p>Le territoire de la MRC chevauche les sections 31M et 32D. Ces deux sections se retrouvent aussi dans le dossier <em>cdem</em> sous format GeoTiff (<em>.tif</em>). Pour charger et traiter des données matricielles dans R, nous utiliserons le package <strong><em>raster</em></strong>.</p>
<hr />
</div>
<div id="traitement-des-donnees-matricielles-avec-raster" class="section level2">
<h2>Traitement des données matricielles avec raster</h2>
<p>Chargeons d’abord l’une des deux sections du CDEM, avec la fonction <code>raster</code>. Cette fonction associe le jeu de données à un objet de type <code>raster</code>, dont les propriétés peuvent être consultées en appelant son nom à la fenêtre de commandes.</p>
<pre class="r"><code>library(raster)
## Loading required package: sp
cdem32D &lt;- raster(&quot;cdem/cdem_dem_032D.tif&quot;)
cdem32D
## class       : RasterLayer 
## dimensions  : 4801, 9601, 46094401  (nrow, ncol, ncell)
## resolution  : 0.0002083333, 0.0002083333  (x, y)
## extent      : -80.0001, -77.9999, 47.9999, 49.0001  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs 
## data source : C:\Users\marchanp\Desktop\atelier_rgeo\cdem\cdem_dem_032D.tif 
## names       : cdem_dem_032D 
## values      : -32768, 32767  (min, max)</code></pre>
<p>Ces propriétés incluent les dimensions du raster (nombre de rangées et colonnes), sa résolution (dans les mêmes unités que le système de coordonnées, ici en degrés), son étendue (semblable à <code>bbox</code> pour les données vectorielles) et son système de coordonnées (en format <em>proj4string</em>). On peut extraire ces valeurs séparément avec les fonctions <code>dim</code>, <code>res</code> <code>extent</code> et <code>crs</code>.</p>
<pre class="r"><code>dim(cdem32D)
## [1] 4801 9601    1
extent(cdem32D)
## class       : Extent 
## xmin        : -80.0001 
## xmax        : -77.9999 
## ymin        : 47.9999 
## ymax        : 49.0001</code></pre>
<p><em>Note:</em> Même si l’expression <em>proj4string</em> du CDEM diffère de celle du jeu de données du MRC, NAD83 et GRS80 sont basés sur le même système de référence géodésique, donc les coordonnées sont bien équivalentes.</p>
<p>Puisque les jeux de données matriciels sont généralement assez volumineux (ex.: 88 Mo pour chaque section du CDEM), <code>raster</code> ne charge pas toutes les données dans la mémoire vive, mais crée plutôt un lien vers le fichier sur le disque. Les fonctions de visualisation prennent quant à elle un échantillon stratifié des données. Par exemple, l’histogramme des valeurs de <code>cdem32D</code> est construit à partir de 100 000 pixels sur ~46 millions.</p>
<pre class="r"><code>hist(cdem32D)
## Warning in .hist1(x, maxpixels = maxpixels, main = main, plot = plot, ...):
## 0% of the raster cells were used. 100000 values used.</code></pre>
<p><img src="atelier_rgeo_files/figure-html/hist_raster-1.png" /><!-- --></p>
<p>C’est aussi le cas de la fonction <code>plot</code>, qui présente une image du jeu de données matriciel. Comme auparavant, il est possible d’y superposer des données vectorielles avec l’option <code>add = TRUE</code> (<code>reset = FALSE</code> n’est pas nécessaire ici).</p>
<pre class="r"><code>plot(cdem32D)
plot(mrc[, &quot;geometry&quot;], add = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/plot_raster-1.png" /><!-- --></p>
<p>Nous allons maintenant charger la deuxième section du CDEM, puis combiner les deux jeux de données en une seule matrice avec la fonction <code>merge</code>.</p>
<pre class="r"><code>cdem31M &lt;- raster(&quot;cdem/cdem_dem_031M.tif&quot;)
cdem &lt;- merge(cdem32D, cdem31M)</code></pre>
<p>On peut vérifier que les étendues (<em>extent</em>) des deux sections se chevauchent d’exactement une rangée de pixels. Pour ces pixels, <code>merge</code> utilise les données du premier objet (<code>cdem32D</code>), en autant qu’elles ne soient pas nulles (<code>NA</code>).</p>
<p>Dépendamment du système, il est possible que le nouvel objet <code>cdem</code> (350 Mo) soit entièrement chargé dans la mémoire vive. Au-delà d’une certaine taille, les fonctions de <strong><em>raster</em></strong> enregistrent le résultat dans un fichiers temporaire pour économiser la mémoire; cette taille limite peut être modifiée avec <code>rasterOptions()</code>.</p>
<p>Pour réduire l’étendue géographique d’un <code>raster</code> aux limites d’un autre objet spatial (<code>raster</code> ou <code>sf</code>), on utilise la fonction <code>crop</code>. Ici, nous allons extraire la section rectangulaire contenant tout juste la MRC de Rouyn-Noranda.</p>
<pre class="r"><code>rn &lt;- mrc[mrc$MRS_NM_MRC == &quot;Rouyn-Noranda&quot;, ]
cdem &lt;- crop(cdem, rn)

plot(cdem)
plot(rn[, &quot;geometry&quot;], add = TRUE)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/crop_raster-1.png" /><!-- --></p>
<p>Puisque les objets <code>raster</code> sont fondamentalement des matrices de données, on peut y appliquer les mêmes opérations mathématiques de base que les matrices régulières. Par exemple, si <em>X</em> est une matrice dans R, <code>X + 5</code> retourne une matrice où 5 est ajouté à chaque élément de <em>X</em>, et <code>X-Y</code> retourne une matrice où chaque élément de <em>Y</em> est soustrait à l’élément de <em>X</em> correspondant.</p>
<div id="retour4" class="section level3">
<h3>Exercice 4</h3>
<p>À partir de <code>cdem</code>, produisez (a) une carte où l’altitude est exprimée en kilomètres plutôt qu’en mètres et (b) une carte où les régions d’altitude inférieure à 300 mètres sont identifiées.</p>
<p><a href="#sol4">Solution</a></p>
<hr />
<p>Pour exclure les régions de 300 mètres et plus, mais conserver l’information sur l’altitude pour les autres régions, on peut utiliser la fonction <code>mask</code>.</p>
<pre class="r"><code>plot(mask(cdem, cdem &lt; 300, maskvalue = FALSE))</code></pre>
<p><img src="atelier_rgeo_files/figure-html/mask_raster-1.png" /><!-- --></p>
<p>Le paramètre <code>maskvalue</code> indique d’exclure les pixels pour lesquels la condition du masque (<code>cdem &lt; 300</code>) retourne <code>FALSE</code>.</p>
<p>En raison de limites de temps ou de mémoire, il est parfois nécessaire de réduire la résolution de données matricielles. La fonction <code>aggregate</code> appliquée à un objet <code>raster</code> permet de réduire le nombre de pixels par un facteur donné en regroupant les valeurs selon une fonction sommaire. Par exemple, l’instruction suivante regroupe des régions de 50 x 50 pixels en prenant la moyenne des valeurs originales.</p>
<pre class="r"><code>cdem_agg &lt;- aggregate(cdem, fact = 50, fun = mean)
plot(cdem_agg)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/agg_raster-1.png" /><!-- --></p>
<p><strong>Rappel</strong></p>
<ul>
<li>Un jeu de données matriciel associe une valeur à chaque pixel dans une grille régulière. Le package <strong><em>raster</em></strong> permet de traiter ce type de données dans R.</li>
<li>Pour lire un jeu de données matriciel: <code>raster</code>.</li>
<li>En plus d’une matrice de valeurs, les objets <em>raster</em> ont certaines propriétés incluant une étendue (<code>extent</code>), une résolution (<code>res</code>) et un système de coordonnées (<code>crs</code>).</li>
<li>Les opérateurs d’arithmétique (<code>+</code>, <code>-</code>, etc.) et de comparaison (<code>&lt;</code>, <code>==</code>, etc.) s’appliquent à chaque pixel dans un objet <em>raster</em>.</li>
<li><code>mask</code> masque les valeurs d’un <em>raster</em> pour les pixels où une condition s’applique.</li>
<li><code>crop</code> “coupe” une partie d’un <em>raster</em>.</li>
<li><code>merge</code> “colle” ensemble plusieurs objets <em>raster</em>.</li>
<li><code>aggregate</code> réduit la résolution d’un <em>raster</em> en combinant plusieurs pixels et un seul.</li>
</ul>
<hr />
</div>
</div>
<div id="ext" class="section level2">
<h2>Extraire des valeurs d’un raster à partir d’objets géométriques</h2>
<p>Admettons que nous souhaitons vérifier s’il existe un lien entre l’altitude et l’intensité de défoliation due à la livrée des forêts. Pour ce faire, nous devons utiliser une nouvelle fonction, <code>extract</code>, qui extrait les données d’un objet <code>raster</code> pour des coordonnées géographiques spécifiées. Par exemple, l’instruction suivante retourne la valeur du CDEM à la position de l’UQAT (292 m).</p>
<pre class="r"><code>extract(cdem, uqat)
##     
## 292</code></pre>
<p>Quel est le résultat si on extrait les valeurs du CDEM correspondant à un polygone? Essayons avec cinq polygones de défoliation sur le territoire de Rouyn-Noranda.</p>
<pre class="r"><code>livree_rn &lt;- st_intersection(livree2017, rn)
## although coordinates are longitude/latitude, st_intersection assumes that they are planar
## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries
poly_ext &lt;- extract(cdem, livree_rn[1:5, ])</code></pre>
<p><strong>Question</strong>: Le résultat enregistré dans <code>poly_ext</code> est une liste de cinq vecteurs contenant chacun un différent nombre de valeurs. Que pensez-vous que ceux-ci représentent?</p>
<p>Le résultat est une liste où chaque vecteur contient les valeurs du CDEM pour tous les pixels couverts par le polygone correspondant; par défaut, un pixel est compté si son centre se retrouve à l’intérieur du polygone. Si on préfère obtenir une valeur par polygone, il faut préciser une fonction d’agrégation comme argument <code>fun</code>. Ici, nous pouvons prendre la moyenne des valeurs à l’intérieur de chaque polygone.</p>
<p>L’instruction suivante prendra 1 à 2 minutes à s’exécuter, dépendamment de votre ordinateur. Une fois les moyennes calculées, nous enregistrons le résultat dans une nouveau champ de données de l’objet <code>livree_rn</code>.</p>
<pre class="r"><code>moy_cdem &lt;- extract(cdem, livree_rn, fun = mean)
livree_rn$cdem &lt;- moy_cdem[, 1]</code></pre>
<p>Finalement, comparons la distribution de l’altitude des régions touchées par différents niveaux de défoliation.</p>
<pre class="r"><code>boxplot(cdem ~ Ia, data = livree_rn)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/cdem_boxplot-1.png" /><!-- --></p>
<p><strong>Rappel</strong></p>
<ul>
<li><code>extract</code> permet d’extraire des valeurs d’un objet <em>raster</em> à partir de coordonnées spatiales.</li>
<li>Pour un ensemble de points, <code>extract</code> retourne la valeur du <em>raster</em> à ces points.</li>
<li>Pour un ensemble de polygones, <code>extract</code> retourne les valeurs de l’ensemble des pixels couverts par chaque polygone. Ces valeurs peuvent être combinés pour chaque polygone en spécifiant une fonction d’agrégation.</li>
</ul>
<hr />
</div>
<div id="mapview" class="section level2">
<h2>Cartes interactives avec mapview</h2>
<p>Le package <strong><em>mapview</em></strong> permet de visualiser des objets <code>sf</code> ou <code>raster</code> sur une carte interactive (de style Google Maps), avec différentes options de couche de base (ex. OpenStreetMap, OpenTopoMap, World Imagery d’ESRI). Il suffit d’appeler la fonction <code>mapview</code> avec le nom de l’objet spatial à afficher. D’autres données spatiales peuvent y être superposées avec <code>+</code>.</p>
<pre class="r"><code>library(mapview)

mapview(cdem) + livree_rn[, &quot;Niveau&quot;]</code></pre>
<div class="figure">
<img src="images/mapview.png" alt="Exemple mapview" />
<p class="caption">Exemple mapview</p>
</div>
<hr />
</div>
<div id="ref" class="section level2">
<h2>Références supplémentaires (en anglais)</h2>
<ul>
<li><p>Cette formation est basée sur des <a href="https://www.sesync.org/for-you/cyberinfrastructure/training">ateliers</a> présentés au Socio-Environmental Synthesis Center (SESYNC).</p></li>
<li><p>Pour plus d’informations sur les fonctions du package <em>sf</em>, voir les articles hébergés au <a href="https://r-spatial.github.io/sf/" class="uri">https://r-spatial.github.io/sf/</a>.</p></li>
<li><p><a href="http://neondataskills.org/tutorial-series/raster-data-series/">Introduction to Working With Raster Data in R</a> (formation développée par le National Ecological Observation Network)</p></li>
<li><p><a href="https://cran.r-project.org/web/packages/tmap/vignettes/tmap-nutshell.html">Vignette du package <em>tmap</em></a></p></li>
<li><p>Livre gratuit en ligne de Robin Lovelace, <a href="https://geocompr.robinlovelace.net/"><em>Geocomputation in R</em></a></p></li>
<li><p><a href="https://cran.r-project.org/web/views/Spatial.html">Liste détaillée</a> des packages d’analyse spatiale en R.</p></li>
</ul>
<hr />
</div>
<div id="sol" class="section level2">
<h2>Solutions des exercices</h2>
<div id="sol1" class="section level3">
<h3>Exercice 1</h3>
<p>Produisez une carte coloriée par région administrative, ex.: Nord-du-Québec, Côte-Nord, etc.</p>
<pre class="r"><code>plot(mrc[, &quot;MRS_NM_REG&quot;], key.size = lcm(5))</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol1-1.png" /><!-- --></p>
<p><a href="#retour1">Retour</a></p>
</div>
<div id="sol2" class="section level3">
<h3>Exercice 2</h3>
<p>La fonction <code>st_intersection(A, B)</code> retourne l’intersection de deux jeux de données vectoriels <code>A</code> et <code>B</code>, c’est-à-dire les régions où leurs objets géométriques se superposent. Avec cette fonction, identifiez le nombre de MRC situées dans un rayon de 100km du point <code>uqat</code>, puis essayez de les indiquer sur une carte représentant ce rayon.</p>
<pre class="r"><code>inters &lt;- st_intersection(mrc_proj, rayon)
## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries
plot(inters[, &quot;MRS_NM_MRC&quot;], key.size = lcm(5))</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol2-1.png" /><!-- --></p>
<p><a href="#retour2">Retour</a></p>
</div>
<div id="sol3" class="section level3">
<h3>Exercice 3</h3>
<ul>
<li>Déterminer la superficie totale (en hectares) défoliée par la livrée des forêts sur le territoire de la MRC de Rouyn-Noranda.</li>
<li>Produire une carte des surfaces défoliées avec leur niveau d’intensité pour ce territoire.</li>
</ul>
<pre class="r"><code>rn &lt;- mrc[mrc$MRS_NM_MRC == &quot;Rouyn-Noranda&quot;, ]

# Vérifions que les systèmes de coordonnées soient identifiques
st_crs(rn) == st_crs(livree2017)
## [1] TRUE

# Intersection des polygones de défoliation et de la MRC
livree_rn &lt;- st_intersection(livree2017, rn)
## although coordinates are longitude/latitude, st_intersection assumes that they are planar
## Warning: attribute variables are assumed to be spatially constant
## throughout all geometries

# Somme des superficies de l&#39;intersection
sum(livree_rn$SupHaCea)
## [1] 52793.94


plot(livree_rn[, &quot;Ia&quot;], reset = FALSE)
plot(rn[, &quot;geometry&quot;], add = TRUE, reset = FALSE)
plot(uqat, add = TRUE, pch = 20, col = &quot;red&quot;)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol3-1.png" /><!-- --></p>
<p><a href="#retour3">Retour</a></p>
</div>
<div id="sol4" class="section level3">
<h3>Exercice 4</h3>
<p>À partir de <code>cdem</code>, produisez (a) une carte où l’altitude est exprimée en kilomètres plutôt qu’en mètres et (b) une carte où les régions d’altitude inférieure à 300 mètres sont identifiées.</p>
<pre class="r"><code>plot(cdem / 1000)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol4-1.png" /><!-- --></p>
<pre class="r"><code>plot(cdem &lt; 300)</code></pre>
<p><img src="atelier_rgeo_files/figure-html/sol4-2.png" /><!-- --></p>
<p><a href="#retour4">Retour</a></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
